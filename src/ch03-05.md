# 3.5 并发编程：安全并行与异步处理
**——让程序同时做多件事，而不引入竞态条件**

> "并发就像指挥交响乐团——每个乐器独立演奏，但和谐统一。数据竞争则是所有乐器同时即兴发挥的灾难。"  
> —— 某位在调试竞态条件中领悟并发真谛的工程师

并发编程是现代软件的核心需求。AetherLang的并发模型既要保证安全性和性能，又要降低开发者的认知负担。我们基于Actor模型和异步/await语法，构建了一个既强大又易用的并发系统。

## 并发设计哲学

### 设计原则：
1. **无数据竞争**：编译时防止竞态条件
2. **零成本抽象**：并发原语无运行时开销
3. **异步优先**：基于async/await的现代异步编程
4. **错误安全**：并发错误可预测、可恢复

## Actor模型：并发的安全基础

### Actor基础概念：
Actor是并发计算的基本单元，每个Actor有自己的状态，只能通过消息传递与其他Actor通信。

```aether
// 定义Actor
actor Counter {
    state count: i32 = 0;
    
    // 消息处理函数
    fn handle_message(msg: CounterMessage) -> Option<CounterResponse> {
        match msg {
            CounterMessage::Increment => {
                count += 1;
                None
            }
            CounterMessage::GetCount => {
                Some(CounterResponse::Count(count))
            }
            CounterMessage::Reset => {
                count = 0;
                None
            }
        }
    }
}

// 定义消息类型
enum CounterMessage {
    Increment,
    GetCount,
    Reset,
}

enum CounterResponse {
    Count(i32),
}
```

### Actor系统管理：
```aether
// Actor系统管理所有Actor
fn main() async {
    // 创建Actor系统
    let system = ActorSystem::new();
    
    // 启动Counter Actor
    let counter_addr = system.spawn::<Counter>();
    
    // 发送消息给Actor
    counter_addr.send(CounterMessage::Increment).await;
    counter_addr.send(CounterMessage::Increment).await;
    
    // 发送请求并等待响应
    let response = counter_addr.request(CounterMessage::GetCount).await;
    println!("计数: {}", response.unwrap_count());
    
    // 系统关闭时自动停止所有Actor
    system.shutdown().await;
}
```

## 异步编程：async/await语法

### 基础异步函数：
```aether
// 声明异步函数
async fn fetch_data(url: &str) -> Result<String, HttpError> {
    let client = HttpClient::new();
    client.get(url).await?  // 等待异步操作完成
}

// 使用异步函数
async fn process_user_data() -> Result<(), Error> {
    // 顺序执行
    let user_data = fetch_data("/api/users/1").await?;
    let profile = fetch_data("/api/profile/1").await?;
    
    // 并行执行
    let (posts, settings) = join!(
        fetch_data("/api/posts/1"),
        fetch_data("/api/settings/1")
    ).await;
    
    Ok(())
}
```

### 异步流处理：
```aether
// 异步流（类似JavaScript的AsyncIterator）
async fn process_data_stream() {
    let mut stream = data_source::stream();
    
    // 异步迭代
    while let Some(item) = stream.next().await {
        process_item(item).await;
    }
}

// 背压控制的流处理
async fn controlled_stream() {
    let mut stream = fast_data_source::stream();
    
    // 控制处理速率，避免内存溢出
    stream
        .rate_limit(100)  // 每秒最多100个项目
        .buffer(10)       // 缓冲区大小10
        .for_each(|item| async {
            process_item(item).await;
        })
        .await;
}
```

## 消息传递与通道

### 多生产者单消费者通道：
```aether
// 创建通道
fn spawn_workers() async {
    let (tx, rx) = channel::bounded(100);  // 容量100的通道
    
    // 启动多个生产者
    for i in 0..5 {
        let tx_clone = tx.clone();
        spawn(async move {
            for j in 0..20 {
                tx_clone.send(WorkItem { id: i * 20 + j }).await?;
            }
            Ok(())
        });
    }
    
    // 单个消费者
    spawn(async move {
        while let Some(item) = rx.recv().await {
            process_work_item(item).await;
        }
    });
}
```

### 广播通道：
```aether
// 一对多消息广播
fn setup_event_system() async {
    let (tx, _) = broadcast::channel(16);  // 广播通道
    
    // 多个订阅者
    for subscriber_id in 0..3 {
        let mut rx = tx.subscribe();
        spawn(async move {
            while let Ok(event) = rx.recv().await {
                handle_event(subscriber_id, event).await;
            }
        });
    }
    
    // 发布事件
    tx.send(Event::UserLoggedIn).await?;
    tx.send(Event::DataUpdated).await?;
}
```

## 并发安全模式

### 编译时防止数据竞争：
```aether
// 共享状态的安全管理
struct SafeCounter {
    value: Mutex<i32>,  // 互斥锁保护
}

impl SafeCounter {
    async fn increment(&self) {
        let mut guard = self.value.lock().await;  // 异步锁
        *guard += 1;
    }  // 锁自动释放
    
    async fn get(&self) -> i32 {
        let guard = self.value.lock().await;
        *guard
    }
}

// 使用示例
async fn concurrent_updates() {
    let counter = Arc::new(SafeCounter::new());
    
    let tasks = (0..1000).map(|_| {
        let counter = counter.clone();
        spawn(async move {
            counter.increment().await;
        })
    });
    
    join_all(tasks).await;
    println!("最终计数: {}", counter.get().await);
}
```

### 无锁数据结构：
```aether
// 原子操作实现高性能并发
struct AtomicCounter {
    count: AtomicI32,
}

impl AtomicCounter {
    fn increment(&self) {
        self.count.fetch_add(1, Ordering::Relaxed);
    }
    
    fn get(&self) -> i32 {
        self.count.load(Ordering::Acquire)
    }
}

// 使用示例
fn high_performance_counting() {
    let counter = AtomicCounter::new();
    
    parallel_for(0..1_000_000, |i| {
        counter.increment();
    });
    
    println!("计数: {}", counter.get());
}
```

## 错误处理与容错

### Actor监督策略：
```aether
// Actor错误处理与重启策略
actor DatabaseWorker {
    state connection: DbConnection,
    
    // 监督策略
    supervision: RestartStrategy::ExponentialBackoff {
        initial_delay: 1.secs(),
        max_delay: 60.secs(),
        max_retries: 5,
    };
    
    fn handle_message(msg: DbMessage) -> Result<Option<DbResponse>, DbError> {
        match msg {
            DbMessage::Query(sql) => {
                let result = connection.execute(sql)?;  // 可能失败
                Ok(Some(DbResponse::Result(result)))
            }
            // ... 其他消息处理
        }
    }
    
    // Actor崩溃时的恢复逻辑
    fn on_failure(error: &Error) -> RecoveryAction {
        match error {
            DbError::ConnectionLost => RecoveryAction::Restart,
            DbError::InvalidQuery => RecoveryAction::Stop,
            _ => RecoveryAction::Escalate,  // 向上级汇报
        }
    }
}
```

### 异步错误传播：
```aether
// 异步上下文中的错误处理
async fn robust_data_pipeline() -> Result<(), PipelineError> {
    let result = try {
        // 尝试多个可能失败的操作
        let raw_data = fetch_raw_data().await?;
        let validated = validate_data(raw_data).await?;
        let processed = process_in_parallel(validated).await?;
        store_results(processed).await?;
        
        Ok(())
    } catch e: FetchError {
        log::error("数据获取失败: {}", e);
        Retry::after(5.secs()).await?
    } catch e: ValidationError {
        log::error("数据验证失败: {}", e);
        Fallback::use_cached_data().await?
    } catch e: ProcessingError {
        log::error("处理失败: {}", e);
        Err(PipelineError::ProcessingFailed)
    };
    
    result
}
```

## 性能优化模式

### 工作窃取调度：
```aether
// 高性能任务调度
async fn optimized_parallel_processing() {
    let scheduler = WorkStealingScheduler::new();
    
    // 大量小任务
    let tasks = (0..10000).map(|i| {
        scheduler.spawn(async move {
            compute_chunk(i)
        })
    });
    
    // 工作窃取确保负载均衡
    let results = join_all(tasks).await;
    combine_results(results);
}
```

### 零拷贝消息传递：
```aether
// 高性能消息传递
actor ZeroCopyProcessor {
    fn handle_large_data(data: &[u8]) -> Result<(), ProcessError> {
        // 使用引用，避免数据拷贝
        process_large_buffer(data)?;
        
        // 需要所有权时使用移动语义
        Ok(())
    }
}

// 使用示例
async fn send_large_data() {
    let processor = spawn::<ZeroCopyProcessor>();
    let large_buffer = vec![0u8; 1024 * 1024];  // 1MB数据
    
    // 零拷贝发送（移动所有权）
    processor.send(LargeMessage(large_buffer)).await;
}
```

## 实际应用场景

### Web服务器并发处理：
```aether
// 高性能HTTP服务器
actor HttpServer {
    state connections: ConnectionPool,
    state router: RequestRouter,
    
    fn handle_message(msg: HttpRequest) -> async HttpResponse {
        // 异步处理请求
        let connection = self.connections.acquire().await;
        let response = self.router.route(msg, connection).await;
        self.connections.release(connection);
        
        response
    }
}

// 启动服务器
async fn start_server() {
    let server = ActorSystem::new().spawn::<HttpServer>();
    
    // 处理大量并发请求
    for _ in 0..10_000 {
        spawn(async move {
            let response = server.request(HttpRequest::new()).await;
            handle_response(response);
        });
    }
}
```

### 实时数据处理管道：
```aether
// 实时数据管道
async fn realtime_data_pipeline() {
    // 创建处理阶段
    let source = KafkaSource::new("topic");
    let transformer = DataTransformer::new();
    let sink = DatabaseSink::new();
    
    // 构建异步管道
    source
        .stream()
        .map(|data| async move { transformer.transform(data).await })
        .batch(100)  // 每100条一批
        .for_each(|batch| async move {
            sink.store_batch(batch).await
        })
        .await;
}
```

### 游戏服务器并发模型：
```aether
// 游戏服务器Actor架构
actor GameSession {
    state players: HashMap<PlayerId, PlayerState>,
    state world: GameWorld,
    
    fn handle_message(msg: GameMessage) -> Option<GameResponse> {
        match msg {
            GameMessage::PlayerJoin(player) => {
                self.players.insert(player.id, player);
                self.broadcast(PlayerJoinedEvent).await;
                None
            }
            GameMessage::PlayerAction(action) => {
                let result = self.world.process_action(action).await;
                Some(GameResponse::ActionResult(result))
            }
            // ... 其他游戏逻辑
        }
    }
}

actor Matchmaker {
    state waiting_players: VecDeque<Player>,
    
    fn handle_message(msg: MatchmakingMessage) {
        match msg {
            MatchmakingMessage::Queue(player) => {
                self.waiting_players.push_back(player);
                self.try_match_players().await;
            }
        }
    }
    
    async fn try_match_players(&mut self) {
        if self.waiting_players.len() >= 2 {
            let player1 = self.waiting_players.pop_front().unwrap();
            let player2 = self.waiting_players.pop_front().unwrap();
            
            // 创建新游戏会话
            let game_session = spawn::<GameSession>();
            game_session.send(GameMessage::PlayerJoin(player1)).await;
            game_session.send(GameMessage::PlayerJoin(player2)).await;
        }
    }
}
```

## 调试与监控

### 并发调试工具：
```aether
// 死锁检测
async fn deadlock_prevention_example() {
    let lock1 = Mutex::new(());
    let lock2 = Mutex::new(());
    
    // 编译时死锁检测
    let task1 = spawn(async move {
        let _guard1 = lock1.lock().await;
        // 尝试获取第二个锁（可能死锁）
        let _guard2 = lock2.lock().await;  // 警告：可能的死锁顺序
    });
    
    let task2 = spawn(async move {
        let _guard2 = lock2.lock().await;
        let _guard1 = lock1.lock().await;  // 反向顺序，可能死锁
    });
    
    // 运行时死锁检测会警告或报错
    join!(task1, task2);
}

/*
警告：检测到可能的死锁
  --> src/main.aether:15:9
   |
15 |         let _guard2 = lock2.lock().await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 锁获取顺序与任务2相反
   |
帮助：考虑统一锁获取顺序，或使用超时机制
*/
```

### 性能监控：
```aether
// 并发性能指标
async fn monitored_concurrent_operation() {
    let monitor = ConcurrencyMonitor::new();
    
    let task = spawn(async move {
        monitor.record_start("data_processing");
        
        // 被监控的操作
        let result = process_data().await;
        
        monitor.record_end("data_processing");
        result
    });
    
    // 实时监控指标
    spawn(async move {
        while let Some(metrics) = monitor.get_metrics().await {
            println!("活跃任务: {}", metrics.active_tasks);
            println!("吞吐量: {}/s", metrics.throughput);
            sleep(1.secs()).await;
        }
    });
    
    task.await;
}
```

## 测试与验证

### 并发测试：
```aether
// 确定性并发测试
#[concurrent_test]
async fn test_concurrent_counter() {
    let counter = AtomicCounter::new();
    
    // 并发递增测试
    let tasks = (0..1000).map(|_| {
        spawn(async move {
            counter.increment();
        })
    });
    
    join_all(tasks).await;
    assert_eq!(counter.get(), 1000);
}

// 竞态条件检测测试
#[race_test]
async fn test_race_condition_detection() {
    let shared_data = Mutex::new(0);
    
    let task1 = spawn(async move {
        let mut data = shared_data.lock().await;
        *data += 1;
    });
    
    let task2 = spawn(async move {
        let mut data = shared_data.lock().await;  // 测试框架会检测可能的竞态
        *data *= 2;
    });
    
    join!(task1, task2);
}
```

### 模型检查：
```aether
// 使用模型检查验证并发正确性
#[model_check]
actor VerifiedActor {
    state value: i32 = 0;
    
    // 模型检查器会验证所有可能的执行顺序
    fn handle_message(msg: Message) {
        match msg {
            Message::Increment => value += 1,
            Message::Decrement => value -= 1,
        }
        
        // 断言不变式
        invariant(value >= 0, "值不能为负");
    }
}
```

## 与其他语言互操作

### 与Rust异步运行时互操作：
```aether
// 使用Tokio运行时
extern "Rust" {
    async fn tokio_spawn<F>(future: F) -> JoinHandle<F::Output>
    where
        F: Future + Send + 'static;
}

// 在AetherLang中调用Tokio
async fn interop_with_tokio() {
    let handle = tokio_spawn(async move {
        // 在Tokio运行时中执行
        tokio_async_operation().await
    });
    
    let result = handle.await;
    println!("Tokio任务结果: {}", result);
}
```

### 与JavaScript Promise互操作：
```aether
// 调用JavaScript异步函数
extern "JavaScript" {
    async fn fetch(url: &str) -> JsValue;
}

async fn call_js_from_aether() -> Result<(), JsError> {
    let response = fetch("https://api.example.com/data").await?;
    let data = response.json().await?;
    process_js_data(data)
}
```

## 并发模式最佳实践

### 结构化并发：
```aether
// 使用作用域确保所有任务完成
async fn structured_concurrency() {
    async_scope(|scope| {
        // 所有任务都在这个作用域内
        for i in 0..10 {
            scope.spawn(async move {
                process_item(i).await;
            });
        }
        
        // 作用域结束时等待所有任务完成
    }).await;  // 等待所有spawn的任务完成
    
    // 此处所有任务都已完成或取消
}
```

### 资源管理：
```aether
// 使用RAII模式管理并发资源
struct ConnectionPool {
    connections: Vec<Connection>,
    semaphore: Semaphore,
}

impl ConnectionPool {
    async fn get_connection(&self) -> ConnectionGuard<'_> {
        let permit = self.semaphore.acquire().await;
        let connection = self.connections.get(permit.index());
        ConnectionGuard {
            connection,
            _permit: permit,
        }
    }
}

// 自动释放资源
async fn use_connection_pool() {
    let pool = ConnectionPool::new(10);
    
    {
        let connection = pool.get_connection().await;
        use_connection(connection).await;
    } // connection自动释放回池中
}
```

## 并发系统总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| Actor模型 | 基于消息传递的并发 | 无共享状态，避免数据竞争 |
| 异步/await | 现代异步语法 | 代码清晰，性能高效 |
| 编译时安全 | 所有权+借用检查 | 防止内存错误和竞态条件 |
| 错误处理 | 集成Result和?操作符 | 统一的错误处理模型 |
| 性能优化 | 工作窃取、零拷贝 | 接近手动优化的性能 |

**核心创新**：在保持Rust级别并发安全的同时，通过更友好的语法和更好的工具支持，大幅降低了并发编程的难度。

---

## 互动挑战：并发设计练习

```aether
// 挑战1：设计一个高性能的Web爬虫并发架构
// 要求：控制并发数，避免被网站封禁，处理各种网络错误
// 你的设计：

// 挑战2：实现一个多玩家游戏的并发服务器
// 要求：处理玩家输入同步，游戏状态一致性，网络延迟补偿
// 你的设计：

// 挑战3：优化以下存在并发问题的代码
var counter = 0;  // 全局可变状态

async fn problematic_concurrent_function() {
    let tasks = (0..1000).map(|_| {
        spawn(async move {
            counter += 1;  // 数据竞争！
        })
    });
    
    join_all(tasks).await;
    println!("计数: {}", counter);  // 结果不确定
}
```

**思考**：如何用AetherLang的并发模型解决这些问题？

---

**下一章预告**：  
并发系统设计完成后，我们将进入AetherLang的元编程和编译时计算领域。在[第4章]中，我们将探索宏系统、编译时反射和代码生成等高级特性，让编译器成为你的编程助手。

> "好的并发设计应该像好的交通系统——车辆各行其道，有明确的规则和信号，不会相撞也不会堵塞。"  
> —— AetherLang并发设计哲学