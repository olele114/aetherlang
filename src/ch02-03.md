# 2.3 函数语法：如何让签名一目了然？
**——从数学函数到现实代码的优雅映射**

> "函数是编程的基石，好的函数语法应该像好诗——简洁、优美、意蕴深远。"  
> —— 某位在代码重构中领悟到函数美感的架构师

函数是编程语言的核心抽象机制。AetherLang的函数语法设计不仅要考虑技术正确性，更要关注开发者的思维映射——如何让代码读起来像自然语言？

## 函数语法设计的目标

### 设计原则：
1. **清晰性**：一眼看懂参数和返回值
2. **一致性**：与变量声明、类型系统协调
3. **表达力**：支持各种编程范式
4. **简洁性**：减少样板代码

## 基础函数语法探索

### 现有语言的函数语法对比：

```rust
// Rust：明确但略显冗长
fn calculate_area(width: f64, height: f64) -> f64 {
    width * height
}
```

```typescript
// TypeScript：简洁但类型信息后置
function calculateArea(width: number, height: number): number {
    return width * height;
}
```

```swift
// Swift：外部参数名增强可读性
func calculateArea(width: Double, height: Double) -> Double {
    return width * height
}
```

## AetherLang的函数语法设计

### 基础形式：数学函数的直观映射
```aether
// 最简形式：像数学函数 f(x, y) = x + y
fn add(x: i32, y: i32) -> i32 {
    x + y  // 最后一句话是返回值
}

// 带文档注释
/// 计算矩形的面积
/// - 参数 width: 宽度，必须大于0
/// - 参数 height: 高度，必须大于0  
/// - 返回: 面积，单位平方
fn area(width: f64, height: f64) -> f64 {
    assert!(width > 0.0 && height > 0.0, "尺寸必须为正数");
    width * height
}
```

### 参数传递语义：明确所有权
```aether
// 值传递（获取所有权）
fn take_ownership(data: String) -> usize {
    data.len()  // data在此被消耗
}

// 引用传递（只读借用）
fn borrow_data(data: &String) -> usize {
    data.len()  // data仍然可用
}

// 可变引用传递（可修改借用）
fn modify_data(data: &mut String) {
    data.push_str(" modified");
}

// 使用示例
val text = "hello".to_string();
val len = borrow_data(&text);        // 借用，text仍然可用
modify_data(&mut text);              // 可变借用
take_ownership(text);                // 所有权转移，text不再可用
```

## 高级函数特性

### 默认参数与命名参数：
```aether
// 默认参数值
fn connect(
    host: &str, 
    port: u16 = 8080,        // 默认值
    timeout: Duration = Duration::from_secs(30)
) -> Result<Connection, Error> {
    // 实现...
}

// 调用时可以使用命名参数（更清晰）
connect("localhost", port: 9000, timeout: 60.secs())
connect("example.com")  // 使用所有默认值
```

### 可变参数：
```aether
// 接受任意数量的同类型参数
fn sum(numbers: ...i32) -> i32 {
    numbers.iter().sum()
}

// 使用
val total = sum(1, 2, 3, 4, 5)
val empty = sum()  // 也可以没有参数
```

### 泛型函数：
```aether
// 类型参数在函数名后声明
fn find_max<T: Ord>(items: &[T]) -> Option<&T> {
    items.iter().max()
}

// 使用类型推导
val numbers = [3, 1, 4, 1, 5];
val max_num = find_max(&numbers);  // 自动推断T=i32

val strings = ["apple", "banana", "cherry"];
val max_str = find_max(&strings);  // 自动推断T=&str
```

## 返回值处理的创新设计

### 隐式返回：表达式即返回值
```aether
// 单表达式函数（常见于简单计算）
fn square(x: i32) -> i32 {
    x * x  // 没有分号，自动返回
}

// 多表达式函数
fn process_data(data: &[u8]) -> Result<Vec<u8>, Error> {
    let validated = validate_data(data)?;  // ? 传播错误
    let transformed = transform(validated);
    transformed  // 最后一句是返回值
}
```

### 提前返回：`return`关键字的使用
```aether
// 在复杂逻辑中提前返回
fn find_index(items: &[i32], target: i32) -> Option<usize> {
    if items.is_empty() {
        return None;  // 提前返回
    }
    
    for (i, &item) in items.iter().enumerate() {
        if item == target {
            return Some(i);  // 找到立即返回
        }
    }
    
    None  // 最后返回
}
```

### 多返回值：元组解构
```aether
// 返回多个值（使用元组）
fn min_max(items: &[i32]) -> (Option<i32>, Option<i32>) {
    if items.is_empty() {
        (None, None)
    } else {
        let min = items.iter().min().copied();
        let max = items.iter().max().copied();
        (min, max)
    }
}

// 调用时解构
val (min, max) = min_max(&[3, 1, 4, 1, 5]);
println!("最小值: {:?}, 最大值: {:?}", min, max);
```

## 错误处理集成

### Result类型与?操作符：
```aether
// 标准错误处理模式
fn read_config_file(path: &str) -> Result<Config, IoError> {
    let content = fs::read_to_string(path)?;  // 错误自动传播
    let config = toml::from_str(&content)?;   // 解析错误也传播
    Ok(config)
}

// 更复杂的错误处理
fn process_data(data: &[u8]) -> Result<ProcessedData, AppError> {
    match validate_header(data) {
        Ok(header) => {
            let body = extract_body(data, header.length)?;
            Ok(ProcessedData { header, body })
        }
        Err(ValidationError::InvalidFormat) => {
            // 尝试恢复或转换错误
            Err(AppError::CorruptedData)
        }
        Err(e) => Err(e.into()),  // 其他错误直接转换
    }
}
```

### Option类型的便捷处理：
```aether
// 处理可能缺失的值
fn get_username(user_id: u64) -> Option<String> {
    let user = database::find_user(user_id)?;  // 如果是None，提前返回
    Some(user.name)
}

// 链式调用
fn get_user_email(user_id: u64) -> Option<String> {
    database::find_user(user_id)?
        .profile?
        .contact_info?
        .email
        .clone()
}
```

## 函数重载与多态

### 基于参数类型的重载：
```aether
// 相同函数名，不同参数类型
fn parse(input: &str) -> Result<i32, ParseError> {
    input.parse()
}

fn parse(input: &[u8]) -> Result<i32, ParseError> {
    String::from_utf8(input.to_vec())?.parse()
}

// 编译器根据参数类型选择正确版本
val from_str = parse("42");      // 调用&str版本
val from_bytes = parse(b"42");   // 调用&[u8]版本
```

### 基于特质约束的多态：
```aether
// 使用特质约束实现更灵活的多态
trait Display {
    fn show(&self) -> String;
}

fn print_all<T: Display>(items: &[T]) {
    for item in items {
        println!("{}", item.show());
    }
}

// 为不同类型实现Display
impl Display for i32 {
    fn show(&self) -> String {
        format!("数字: {}", self)
    }
}

impl Display for String {
    fn show(&self) -> String {
        format!("字符串: {}", self)
    }
}
```

## 高阶函数与函数式编程支持

### 函数作为参数：
```aether
// 接受函数作为参数
fn apply_twice<T>(f: fn(T) -> T, value: T) -> T {
    f(f(value))
}

// 使用闭包（匿名函数）
val result = apply_twice(|x| x * 2, 5);  // 20

// 更复杂的例子：自定义排序
fn sort_by<T, F>(items: &mut [T], comparator: F) 
where 
    F: Fn(&T, &T) -> Ordering 
{
    items.sort_by(comparator);
}

val mut numbers = [3, 1, 4, 1, 5];
sort_by(&mut numbers, |a, b| a.cmp(b));  // 升序
```

### 返回函数（函数工厂）：
```aether
// 创建特定功能的函数
fn multiplier(factor: i32) -> fn(i32) -> i32 {
    move |x| x * factor  // 捕获factor
}

val double = multiplier(2);
val triple = multiplier(3);

println!("{}", double(5));  // 10
println!("{}", triple(5));  // 15
```

## 异步函数支持

### async/await语法：
```aether
// 异步函数声明
async fn fetch_data(url: &str) -> Result<String, HttpError> {
    let response = http::get(url).await?;
    response.text().await
}

// 在异步上下文中使用
async fn process_user_data(user_id: u64) -> Result<Report, Error> {
    let user = fetch_user(user_id).await?;
    let posts = fetch_posts(user_id).await?;
    
    // 并行执行多个异步任务
    let (profile, settings) = join!(
        fetch_profile(user_id),
        fetch_settings(user_id)
    ).await;
    
    generate_report(user, posts, profile?, settings?)
}
```

## 属性宏增强函数功能

### 编译时功能增强：
```aether
// 内联提示
#[inline(always)]
fn hot_function(x: i32) -> i32 {
    x * x + x
}

// 测试函数
#[test]
fn test_addition() {
    assert_eq!(add(2, 3), 5);
}

// 性能分析
#[profile]
fn expensive_computation(data: &[f64]) -> f64 {
    data.iter().map(|x| x.log(2.0)).sum()
}

// 条件编译
#[cfg(target_os = "linux")]
fn platform_specific() -> String {
    "Running on Linux".to_string()
}
```

## 错误信息与开发者体验

### 友好的类型错误：
```aether
// 当类型不匹配时
fn expect_string(s: &str) -> usize {
    s.len()
}

val number = 42;
expect_string(number);  // 错误！

/*
错误：类型不匹配
  --> src/main.aether:15:17
   |
15 | expect_string(number);
   |               ^^^^^^ 期望 &str，实际得到 i32
   |
帮助：考虑使用 to_string() 转换：
      expect_string(number.to_string().as_str())
*/
```

### 生命周期错误指导：
```aether
fn bad_reference() -> &str {
    let s = String::from("hello");
    &s  // 错误！返回局部变量的引用
}

/*
错误：返回了局部变量的引用
  --> src/main.aether:20:5
   |
20 |     &s
   |     ^^ 返回了在函数内分配的值的引用
   |
帮助：考虑返回所有权而不是引用：
      fn good_function() -> String {
          String::from("hello")
      }
*/
```

## 实际编码示例

### 完整的业务逻辑函数：
```aether
/// 处理用户订单
/// - 验证用户权限
/// - 检查库存
/// - 创建订单记录
/// - 发送确认通知
async fn process_order(
    user_id: u64,
    product_id: u64, 
    quantity: u32
) -> Result<Order, OrderError> {
    // 输入验证
    guard!(quantity > 0, OrderError::InvalidQuantity);
    
    // 并行检查用户和产品信息
    let (user, product) = join!(
        user_service::find_user(user_id),
        product_service::get_product(product_id)
    ).await?;
    
    // 业务逻辑验证
    guard!(user.can_purchase(), OrderError::UserRestricted);
    guard!(product.in_stock(quantity), OrderError::OutOfStock);
    
    // 创建订单
    let order = Order::new(user.id, product.id, quantity);
    order_service::save(order).await?;
    
    // 异步发送通知（不阻塞主流程）
    spawn(async {
        let _ = notification_service::send_order_confirmation(user.email, order.id).await;
    });
    
    Ok(order)
}
```

## 语法决策总结

经过多轮设计迭代，AetherLang的函数语法确定为：

| 特性 | 语法 | 设计理由 |
|------|------|----------|
| 函数声明 | `fn name(params) -> return_type` | 清晰直观，类似数学函数 |
| 参数传递 | 值/引用/可变引用明确区分 | 所有权系统集成 |
| 返回值 | 隐式返回 + 显式return | 减少样板代码，保持灵活性 |
| 错误处理 | Result + ?操作符 | 强制错误处理，语法简洁 |
| 泛型支持 | `fn name<T: Trait>(...)` | 与特质系统一致 |
| 异步函数 | `async fn ... await` | 现代异步编程标准 |

**核心原则**：让函数签名成为自文档化的API契约。

---

## 互动挑战：函数设计练习

```aether
// 挑战1：设计一个安全的字符串处理函数
// 要求：接受字符串，返回处理后的新字符串，不修改原字符串
fn process_string(input: &str) -> String {
    // 你的实现...
}

// 挑战2：设计一个灵活的过滤函数
// 要求：接受任意类型的切片和谓词函数，返回过滤后的向量
fn filter<T, F>(items: &[T], predicate: F) -> Vec<T> 
where 
    F: Fn(&T) -> bool,
    T: Clone  // 为什么需要这个约束？
{
    // 你的实现...
}

// 挑战3：错误处理最佳实践
// 重构以下函数，使其更符合AetherLang的错误处理习惯
fn parse_config(file_path: &str) -> Config {
    let content = fs::read_to_string(file_path);
    if content.is_err() {
        panic!("无法读取文件");
    }
    let config = toml::from_str(&content.unwrap());
    if config.is_err() {
        panic!("配置解析失败");
    }
    config.unwrap()
}
```

**思考**：这些函数设计有什么问题？如何改进？

---

**下一节预告**：  
函数语法设计完成后，我们将进入更激动人心的领域：控制流语法。在[2.4]中，我们将设计`if`、`match`、循环等控制结构，让AetherLang的代码既强大又优雅。

> "好的函数设计应该像好的对话——输入明确，输出清晰，错误处理得体。"  
> —— AetherLang函数设计哲学