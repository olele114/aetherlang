# 2.4 控制流语法：让代码有逻辑地"流动"
**——从条件分支到模式匹配的优雅演进**

> "控制流是程序的脉搏——它决定了代码如何呼吸和思考。"  
> —— 某位在调试复杂条件逻辑时顿悟的程序员

控制流是编程语言中最能体现设计哲学的部分。是像C语言那样简单直接，还是像函数式语言那样强调表达式？AetherLang选择了第三条路：既保持命令式的直观性，又吸收函数式的表达力。

## 设计目标：清晰、安全、表达力强

### 核心原则：
1. **表达式优先**：尽可能让控制结构返回有意义的值
2. **无空引用**：强制处理所有可能的情况
3. **模式匹配**：统一的条件处理机制
4. **错误处理集成**：让错误成为正常的控制流

## 条件表达式：if的进化

### 基础if-else语法：
```aether
// 传统但清晰的语法
fn check_temperature(temp: f64) -> &'static str {
    if temp > 30.0 {
        "炎热"
    } else if temp > 20.0 {
        "舒适"
    } else {
        "凉爽"
    }  // 整个if-else链是一个表达式，返回最后执行的分支的值
}
```

### 作为表达式的if：
```aether
// if可以出现在任何需要值的地方
val category = if score >= 90 {
    "优秀"
} else if score >= 60 {
    "及格"
} else {
    "不及格"
};

val message = "你的成绩是：" + category;
```

### 条件赋值模式：
```aether
// 替代三元操作符的更安全方式
val max = if a > b { a } else { b };

// 与let结合的模式匹配条件
val description = if let Some(name) = user_name {
    format!("用户: {}", name)
} else {
    "匿名用户".to_string()
};
```

## 模式匹配：match表达式的强大能力

### 基础匹配：
```aether
// 枚举类型的匹配
enum HttpStatus {
    Ok = 200,
    NotFound = 404,
    ServerError = 500,
}

fn status_message(status: HttpStatus) -> String {
    match status {
        HttpStatus::Ok => "请求成功".to_string(),
        HttpStatus::NotFound => "资源未找到".to_string(),
        HttpStatus::ServerError => "服务器错误".to_string(),
    }
}
```

### 模式解构：
```aether
// 结构体解构
struct Point { x: i32, y: i32 }

fn process_point(point: Point) -> String {
    match point {
        Point { x: 0, y: 0 } => "原点".to_string(),
        Point { x, y: 0 } => format!("X轴上的点: {}", x),
        Point { x: 0, y } => format!("Y轴上的点: {}", y),
        Point { x, y } => format!("坐标: ({}, {})", x, y),
    }
}
```

### 守卫条件：
```aether
// 在模式基础上添加条件
fn check_number(n: i32) -> String {
    match n {
        x if x < 0 => "负数".to_string(),
        0 => "零".to_string(),
        1 | 2 | 3 => "小正数".to_string(),  // 或模式
        x if x % 2 == 0 => "偶数".to_string(),
        _ => "其他正数".to_string(),  // 通配符
    }
}
```

### 穷尽性检查：
```aether
// 编译器确保所有情况都被处理
enum Direction { Up, Down, Left, Right }

fn handle_direction(dir: Direction) {
    match dir {
        Direction::Up => move_up(),
        Direction::Down => move_down(),
        Direction::Left => move_left(),
        Direction::Right => move_right(),
        // 如果没有穷尽所有情况，编译错误！
    }
}
```

## 循环结构：三种不同的迭代方式

### while循环：条件循环
```aether
// 传统while循环
fn countdown(mut n: i32) {
    while n > 0 {
        println!("{}", n);
        n -= 1;
    }
    println!("发射!");
}

// while let 模式
fn process_queue(mut queue: Vec<Task>) {
    while let Some(task) = queue.pop() {
        execute_task(task);
    }
}
```

### for循环：迭代器模式
```aether
// 遍历集合
fn print_numbers(numbers: &[i32]) {
    for number in numbers {
        println!("{}", number);
    }
}

// 带索引的遍历
fn process_with_index(items: &[String]) {
    for (index, item) in items.iter().enumerate() {
        println!("{}: {}", index, item);
    }
}

// 范围迭代
fn sum_to_n(n: i32) -> i32 {
    let mut total = 0;
    for i in 1..=n {  // 包含n的范围
        total += i;
    }
    total
}
```

### loop循环：无限循环与可控退出
```aether
// 基本无限循环
fn wait_for_event() -> Event {
    loop {
        if let Some(event) = check_event() {
            return event;  // 通过return退出
        }
        sleep(100);
    }
}

// 使用break返回值
fn find_target(numbers: &[i32], target: i32) -> Option<usize> {
    let mut index = 0;
    loop {
        if index >= numbers.len() {
            break None;  // break可以返回值
        }
        if numbers[index] == target {
            break Some(index);
        }
        index += 1;
    }
}
```

## 错误处理的控制流集成

### ?操作符的流程控制：
```aether
// 错误传播作为控制流
fn complex_operation() -> Result<Data, AppError> {
    let config = load_config()?;           // 错误则提前返回
    let input = read_input_file()?;       // 同上
    let processed = process_data(input)?;  // 同上
    Ok(processed)
}
```

### try块：错误处理的作用域
```aether
// 局部错误处理
fn attempt_operation() -> Result<(), Error> {
    try {  // try块捕获所有?操作符的错误
        let data = risky_operation()?;
        let result = another_risk()?;
        save_result(result)?;
    } catch e {  // 统一处理错误
        log::error("操作失败: {}", e);
        rollback()?;
    }
    Ok(())
}
```

## 异步控制流：async/await集成

### 异步循环：
```aether
// 异步迭代
async fn process_stream(mut stream: DataStream) -> Result<(), IoError> {
    while let Some(chunk) = stream.next().await? {  // 异步等待下一个数据块
        process_chunk(chunk).await?;
    }
    Ok(())
}
```

### 异步模式匹配：
```aether
// 在异步上下文中使用模式匹配
async fn handle_request(request: Request) -> Response {
    match request.method {
        Method::Get => handle_get(request).await,
        Method::Post => handle_post(request).await,
        Method::Put => handle_put(request).await,
        _ => Response::error(405, "方法不允许"),
    }
}
```

## 控制流的高级特性

### 标签循环：复杂循环控制
```aether
// 带标签的break和continue
fn find_in_matrix(matrix: &[[i32; 3]; 3], target: i32) -> Option<(usize, usize)> {
    'outer: for (i, row) in matrix.iter().enumerate() {
        for (j, &element) in row.iter().enumerate() {
            if element == target {
                break 'outer Some((i, j));  // 跳出外层循环
            }
            if element < 0 {
                continue 'outer;  // 跳过当前行
            }
        }
    }
    None
}
```

### 模式匹配中的@绑定：
```aether
// 同时匹配模式并绑定变量
fn process_range(value: i32) -> String {
    match value {
        low @ 0..=10 => format!("小数字: {}", low),
        mid @ 11..=100 => format!("中等数字: {}", mid),
        high @ _ => format!("大数字: {}", high),  // 使用@捕获通配符匹配的值
    }
}
```

## 条件编译与编译时控制流

### cfg属性：平台特定代码
```aether
// 条件编译
fn get_platform_info() -> String {
    #[cfg(target_os = "linux")]
    {
        "运行在Linux系统".to_string()
    }
    
    #[cfg(target_os = "windows")]
    {
        "运行在Windows系统".to_string()
    }
    
    #[cfg(not(any(target_os = "linux", target_os = "windows")))]
    {
        "运行在其他系统".to_string()
    }
}
```

### 编译时断言：
```aether
// 在编译时检查条件
const MAX_SIZE: usize = 1024;

fn setup_buffer() {
    compile_assert!(MAX_SIZE > 0, "缓冲区大小必须为正数");
    compile_assert!(MAX_SIZE % 8 == 0, "缓冲区大小必须是8的倍数");
    
    // 只有在编译时条件满足时，代码才会编译
    let buffer = [0u8; MAX_SIZE];
}
```

## 领域特定控制流

### 数据库事务控制流：
```aether
// 事务作为控制流结构
fn transfer_funds(from: AccountId, to: AccountId, amount: f64) -> Result<(), DbError> {
    transaction {  // 自定义控制流结构
        let balance = get_balance(from)?;
        guard!(balance >= amount, DbError::InsufficientFunds);
        
        debit_account(from, amount)?;
        credit_account(to, amount)?;
        
        log_transaction(from, to, amount)?;
    }  // 自动提交或回滚
}
```

### 资源管理控制流：
```aether
// 自动资源管理
fn process_file(path: &str) -> Result<(), IoError> {
    using file = File::open(path)? {  // 确保文件被关闭
        let content = file.read_all()?;
        process_content(content)?;
    }  // 文件自动关闭
    
    Ok(())
}
```

## 错误信息与开发者指导

### 模式匹配错误指导：
```aether
// 当匹配不完整时
enum Color { Red, Green, Blue }

fn handle_color(color: Color) -> String {
    match color {
        Color::Red => "红色".to_string(),
        // 缺少Green和Blue的处理！
    }
}

/*
错误：匹配不是穷尽的
  --> src/main.aether:15:5
   |
15 |     match color {
   |     ^^^^^ 模式`Green`和`Blue`没有被覆盖
   |
帮助：确保处理所有可能的情况：
      match color {
          Color::Red => "红色",
          Color::Green => "绿色", 
          Color::Blue => "蓝色",
      }
*/
```

### 循环优化建议：
```aether
// 编译器可能给出的性能建议
fn sum_squares(numbers: &[i32]) -> i32 {
    let mut sum = 0;
    for i in 0..numbers.len() {
        sum += numbers[i] * numbers[i];  // 使用索引访问
    }
    sum
}

/*
提示：考虑使用迭代器以获得更好性能
  --> src/main.aether:23:5
   |
23 |     for i in 0..numbers.len() {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 使用索引可能较慢
   |
建议：for number in numbers {
          sum += number * number;
      }
*/
```

## 实际业务逻辑示例

### 完整的订单处理流程：
```aether
fn process_order(order: Order) -> Result<Receipt, OrderError> {
    // 验证阶段
    let validated = match validate_order(&order) {
        Ok(valid) => valid,
        Err(ValidationError::InvalidItems) => {
            return Err(OrderError::InvalidOrder);
        }
        Err(ValidationError::InsufficientStock(items)) => {
            notify_backorder(items);
            return Err(OrderError::OutOfStock);
        }
    };
    
    // 处理阶段
    let result = try {
        let payment = process_payment(validated)?;
        let shipment = arrange_shipment(validated)?;
        generate_receipt(payment, shipment)
    } catch e: PaymentError {
        log::warn("支付失败: {}", e);
        attempt_alternative_payment(validated)?
    } catch e: ShippingError {
        log::error("物流失败: {}", e);
        notify_customer_delay(validated);
        return Err(OrderError::ShippingIssue);
    };
    
    // 完成阶段
    match result {
        Ok(receipt) => {
            send_confirmation(validated.customer_email, &receipt);
            Ok(receipt)
        }
        Err(e) => {
            rollback_order(validated);
            Err(e.into())
        }
    }
}
```

## 控制流语法决策总结

| 结构 | 语法特性 | 设计理由 |
|------|----------|----------|
| if表达式 | 返回值，无三元操作符 | 统一条件处理，减少特殊语法 |
| match表达式 | 模式匹配，穷尽检查 | 安全处理所有情况，强大解构能力 |
| 循环 | for/while/loop明确分工 | 不同场景使用最合适的循环 |
| 错误处理 | ?操作符，try块 | 错误作为正常控制流，减少嵌套 |
| 异步 | async/await集成 | 现代异步编程标准 |

**核心创新**：将错误处理、资源管理等传统上通过库实现的功能，整合为一级语言特性。

---

## 互动挑战：控制流重构练习

```aether
// 挑战1：重构复杂的嵌套if-else
// 原始代码（难以维护）
fn calculate_discount(age: i32, is_student: bool, is_vip: bool) -> f64 {
    if age < 18 {
        if is_student {
            0.2
        } else {
            0.1
        }
    } else {
        if age > 65 {
            if is_vip {
                0.3
            } else {
                0.25
            }
        } else {
            if is_vip {
                0.15
            } else {
                0.0
            }
        }
    }
}

// 挑战2：使用模式匹配优化错误处理
// 原始代码（重复的错误检查）
fn parse_config(data: &[u8]) -> Result<Config, ConfigError> {
    if data.len() < 4 {
        return Err(ConfigError::InvalidLength);
    }
    if data[0] != b'C' || data[1] != b'F' || data[2] != b'G' {
        return Err(ConfigError::InvalidHeader);
    }
    if data[3] != 1 {
        return Err(ConfigError::UnsupportedVersion);
    }
    // ... 更多检查
}

// 挑战3：异步控制流优化
// 原始代码（顺序执行，性能差）
async fn load_user_data(user_id: u64) -> Result<UserData, Error> {
    let profile = load_profile(user_id).await?;
    let settings = load_settings(user_id).await?;
    let history = load_history(user_id).await?;
    Ok(UserData { profile, settings, history })
}
```

**思考**：如何用AetherLang的控制流特性重构这些代码，使其更清晰、更安全、更高效？

---

**下一节预告**：  
控制流设计完成后，我们将进入类型系统设计。在[第3章]中，我们将探索AetherLang的类型系统如何平衡灵活性与安全性，包括泛型、特质、关联类型等高级特性。

> "好的控制流应该像好的交通系统——让数据顺畅流动，同时在关键路口有明确的信号和保障。"  
> —— AetherLang控制流设计理念