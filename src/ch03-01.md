# 3.1 ç±»å‹ç³»ç»Ÿï¼šç¼–è¯‘å™¨çš„"ç†æ€§å®ˆæŠ¤è€…"
**â€”â€”åœ¨çµæ´»æ€§ä¸å®‰å…¨æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ç‚¹**

> "ç±»å‹ç³»ç»Ÿå°±åƒç¼–ç¨‹è¯­è¨€çš„å…ç–«ç³»ç»Ÿâ€”â€”å®ƒé˜»æ­¢é”™è¯¯ä¼ æ’­ï¼Œä½†ä¸åº”è¿‡åº¦é˜²å¾¡å¯¼è‡´'è‡ªä½“å…ç–«ç–¾ç—…'ã€‚"  
> â€”â€” æŸä½åœ¨ç±»å‹ç†è®ºä¸­å¯»æ‰¾å®ç”¨ä¸»ä¹‰çš„å·¥ç¨‹å¸ˆ

ç±»å‹ç³»ç»Ÿæ˜¯ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„æ ¸å¿ƒã€‚AetherLangçš„ç±»å‹ç³»ç»Ÿæ—¢è¦æä¾›å¼ºå¤§çš„ç¼–è¯‘æ—¶ä¿éšœï¼Œåˆè¦é¿å…è¿‡åº¦å¤æ‚åŒ–å¼€å‘ä½“éªŒã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ï¼š**è®©ç±»å‹ç³»ç»Ÿæˆä¸ºå¼€å‘è€…çš„å¾—åŠ›åŠ©æ‰‹ï¼Œè€Œä¸æ˜¯ä¸¥å‰çš„ç›‘å·¥**ã€‚

## ç±»å‹ç³»ç»Ÿè®¾è®¡å“²å­¦

### è®¾è®¡åŸåˆ™ï¼š
1. **æ¸è¿›ä¸¥æ ¼**ï¼šä»ç®€å•åˆ°å¤æ‚ï¼Œé€æ­¥å¼•å…¥ç±»å‹çº¦æŸ
2. **ç±»å‹æ¨å¯¼**ï¼šç¼–è¯‘å™¨èƒ½æ¨æ–­çš„ï¼Œç»ä¸è¦æ±‚ç”¨æˆ·å†™
3. **é›¶æˆæœ¬æŠ½è±¡**ï¼šé«˜çº§ç±»å‹ç‰¹æ€§ä¸äº§ç”Ÿè¿è¡Œæ—¶å¼€é”€
4. **é”™è¯¯å‹å¥½**ï¼šç±»å‹é”™è¯¯è¦åƒå¯¼å¸ˆï¼Œè€Œä¸æ˜¯è€ƒå®˜

## åŸºç¡€ç±»å‹ç³»ç»Ÿ

### æ ‡é‡ç±»å‹ï¼šæ„å»ºä¸€åˆ‡çš„åŸºçŸ³
```aether
// æ•´æ•°ç±»å‹ï¼šæ˜ç¡®ä½å®½ï¼Œæ— æ­§ä¹‰
val age: i32 = 25;           // 32ä½æœ‰ç¬¦å·æ•´æ•°
val count: u64 = 1000;       // 64ä½æ— ç¬¦å·æ•´æ•°  
val tiny: i8 = -128;         // 8ä½æœ‰ç¬¦å·æ•´æ•°

// æµ®ç‚¹ç±»å‹ï¼šIEEE 754æ ‡å‡†
val price: f64 = 19.99;      // 64ä½åŒç²¾åº¦
val ratio: f32 = 0.5;        // 32ä½å•ç²¾åº¦

// å¸ƒå°”ç±»å‹ï¼šä¸¥æ ¼çš„true/false
val is_valid: bool = true;
val is_empty: bool = false;

// å­—ç¬¦ç±»å‹ï¼šUnicodeæ”¯æŒ
let letter: char = 'A';
let emoji: char = 'ğŸ˜Š';
let chinese: char = 'ä¸­';
```

### æ–‡æœ¬ç±»å‹ï¼šå­—ç¬¦ä¸²çš„å¤šç§è¡¨ç¤º
```aether
// å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼šä¸å¯å˜è§†å›¾
val greeting: &str = "Hello, World!";

// åŠ¨æ€å­—ç¬¦ä¸²ï¼šå¯ä¿®æ”¹çš„å­—ç¬¦ä¸²
val message: String = String::from("å¯ä¿®æ”¹çš„æ–‡æœ¬");
message.push_str(" è¿½åŠ å†…å®¹");

// å­—ç¬¦æ•°ç»„ï¼šå›ºå®šé•¿åº¦
val fixed_text: [char; 5] = ['H', 'e', 'l', 'l', 'o'];

// å­—èŠ‚å­—ç¬¦ä¸²ï¼šäºŒè¿›åˆ¶æ•°æ®
val raw_bytes: &[u8] = b"raw bytes";
```

## å¤åˆç±»å‹ï¼šæ•°æ®çš„ç»“æ„åŒ–

### å…ƒç»„ï¼šè½»é‡çº§ç»„åˆ
```aether
// ç±»å‹æ¨å¯¼çš„å…ƒç»„
val point = (10, 20);           // æ¨å¯¼ä¸º (i32, i32)
val mixed = ("Alice", 25, true); // (&str, i32, bool)

// æ˜¾å¼ç±»å‹æ ‡æ³¨
val coordinates: (f64, f64) = (40.7128, -74.0060);

// æ¨¡å¼åŒ¹é…è§£æ„
val (x, y) = point;
println!("x={}, y={}", x, y);

// ç´¢å¼•è®¿é—®
println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}", mixed.0);
```

### æ•°ç»„ï¼šåŒè´¨æ•°æ®çš„é›†åˆ
```aether
// å›ºå®šé•¿åº¦æ•°ç»„
val numbers: [i32; 5] = [1, 2, 3, 4, 5];
val zeros = [0; 10];           // 10ä¸ª0çš„æ•°ç»„

// åˆ‡ç‰‡ï¼šæ•°ç»„çš„è§†å›¾
val slice: &[i32] = &numbers[1..4];  // [2, 3, 4]

// åŠ¨æ€æ•°ç»„ï¼šè¿è¡Œæ—¶å¯å˜é•¿åº¦
val mut dynamic: Vec<i32> = vec![1, 2, 3];
dynamic.push(4);
dynamic.pop();
```

### ç»“æ„ä½“ï¼šè‡ªå®šä¹‰æ•°æ®ç»“æ„
```aether
// å®šä¹‰ç»“æ„ä½“
struct User {
    name: String,
    age: u32,
    email: String,
    is_active: bool,
}

// åˆ›å»ºå®ä¾‹
val user = User {
    name: "Alice".to_string(),
    age: 25,
    email: "alice@example.com".to_string(),
    is_active: true,
};

// æ›´æ–°è¯­æ³•
val updated_user = User {
    email: "new@example.com".to_string(),
    ..user  // ç»§æ‰¿å…¶ä»–å­—æ®µ
};
```

## æšä¸¾ä¸æ¨¡å¼åŒ¹é…ï¼šç±»å‹å®‰å…¨çš„è”åˆ

### åŸºç¡€æšä¸¾ï¼š
```aether
// ç®€å•æšä¸¾
enum Color {
    Red,
    Green,
    Blue,
}

// å¸¦æ•°æ®çš„æšä¸¾
enum WebEvent {
    PageLoad,                    // æ— æ•°æ®
    KeyPress(char),             // å•ä¸ªæ•°æ®
    Click { x: i32, y: i32 },   // åŒ¿åç»“æ„ä½“
}
```

### å¼ºå¤§çš„æ¨¡å¼åŒ¹é…ï¼š
```aether
fn handle_event(event: WebEvent) -> String {
    match event {
        WebEvent::PageLoad => "é¡µé¢åŠ è½½å®Œæˆ".to_string(),
        WebEvent::KeyPress(key) => format!("æŒ‰é”®: {}", key),
        WebEvent::Click { x, y } => format!("ç‚¹å‡»ä½ç½®: ({}, {})", x, y),
    }
}

// ä½¿ç”¨ç¤ºä¾‹
val event1 = WebEvent::PageLoad;
val event2 = WebEvent::KeyPress('A');
val event3 = WebEvent::Click { x: 100, y: 200 };
```

## ç±»å‹æ¨å¯¼ï¼šè®©ç¼–è¯‘å™¨çŒœçŒœä½ çš„å¿ƒæ€

### åŸºç¡€ç±»å‹æ¨å¯¼ï¼š
```aether
// ç¼–è¯‘å™¨è‡ªåŠ¨æ¨æ–­ç±»å‹
val name = "Alice";           // æ¨å¯¼ä¸º &str
val age = 25;                // æ¨å¯¼ä¸º i32
let scores = [95.5, 87.0, 92.5];  // æ¨å¯¼ä¸º [f64; 3]

// å‡½æ•°è¿”å›ç±»å‹æ¨å¯¼
fn add(x: i32, y: i32) -> i32 {  // æ˜¾å¼æ ‡æ³¨
    x + y
}

fn multiply(x: i32, y: i32) {    // æ¨å¯¼ä¸º i32
    x * y
}
```

### æ³›å‹ä¸Šä¸‹æ–‡ä¸­çš„æ¨å¯¼ï¼š
```aether
// æ³›å‹å‡½æ•°ä¸­çš„ç±»å‹æ¨å¯¼
fn identity<T>(value: T) -> T {
    value
}

val num = identity(42);      // T æ¨å¯¼ä¸º i32
val text = identity("hello"); // T æ¨å¯¼ä¸º &str

// é›†åˆç±»å‹æ¨å¯¼
val numbers = vec![1, 2, 3];    // Vec<i32>
let strings = vec!["a", "b"];   // Vec<&str>
```

### ä¸Šä¸‹æ–‡ç±»å‹æ¨å¯¼ï¼š
```aether
// æ ¹æ®ä½¿ç”¨ä¸Šä¸‹æ–‡æ¨æ–­ç±»å‹
fn process_numbers(numbers: &[i32]) {
    // ...
}

val data = [1, 2, 3];  // æ ¹æ®å‡½æ•°ç­¾åï¼Œæ¨å¯¼ä¸º [i32; 3]
process_numbers(&data);
```

## ç±»å‹åˆ«åä¸è‡ªå®šä¹‰ç±»å‹

### ç±»å‹åˆ«åï¼šç®€åŒ–å¤æ‚ç±»å‹
```aether
// ä¸ºå¤æ‚ç±»å‹åˆ›å»ºåˆ«å
type UserId = u64;
type Email = String;
type Result<T> = std::result::Result<T, Error>;

// ä½¿ç”¨åˆ«å
fn find_user(id: UserId) -> Result<User> {
    // ...
}

val user_id: UserId = 12345;
val email: Email = "user@example.com".to_string();
```

### æ–°ç±»å‹æ¨¡å¼ï¼šç±»å‹å®‰å…¨çš„åŒ…è£…
```aether
// åˆ›å»ºæ–°ç±»å‹ï¼Œé¿å…åŸå§‹ç±»å‹è¯¯ç”¨
struct UserId(u64);
struct ProductId(u64);

// è™½ç„¶åº•å±‚éƒ½æ˜¯u64ï¼Œä½†ç±»å‹ä¸åŒ
fn get_user(id: UserId) -> User { ... }
fn get_product(id: ProductId) -> Product { ... }

// ç¼–è¯‘æ—¶é˜²æ­¢é”™è¯¯
val user_id = UserId(123);
val product_id = ProductId(456);

// get_user(product_id);  // ç¼–è¯‘é”™è¯¯ï¼ç±»å‹ä¸åŒ¹é…
```

## å¯é€‰ç±»å‹ä¸é”™è¯¯å¤„ç†é›†æˆ

### Optionç±»å‹ï¼šæ˜ç¡®å¤„ç†ç©ºå€¼
```aether
// æ›¿ä»£nullçš„å®‰å…¨æ–¹æ¡ˆ
fn find_user(name: &str) -> Option<User> {
    if name == "admin" {
        Some(User { /* ... */ })
    } else {
        None  // æ˜ç¡®è¡¨ç¤ºæ²¡æœ‰æ‰¾åˆ°
    }
}

// å®‰å…¨çš„ä½¿ç”¨æ–¹å¼
match find_user("alice") {
    Some(user) => println!("æ‰¾åˆ°ç”¨æˆ·: {}", user.name),
    None => println!("ç”¨æˆ·ä¸å­˜åœ¨"),
}
```

### Resultç±»å‹ï¼šé›†æˆé”™è¯¯å¤„ç†
```aether
// å‡½æ•°å¯èƒ½å¤±è´¥æ—¶è¿”å›Result
fn parse_number(s: &str) -> Result<i32, ParseError> {
    s.parse().map_err(|_| ParseError::InvalidNumber)
}

// ä½¿ç”¨?æ“ä½œç¬¦ç®€åŒ–é”™è¯¯å¤„ç†
fn calculate(s: &str) -> Result<i32, ParseError> {
    let num = parse_number(s)?;  // é”™è¯¯è‡ªåŠ¨ä¼ æ’­
    Ok(num * 2)
}
```

## ç±»å‹è½¬æ¢ä¸å¼ºåˆ¶è½¬æ¢

### æ˜¾å¼è½¬æ¢ï¼šå®‰å…¨ç¬¬ä¸€
```aether
// å¿…é¡»æ˜¾å¼è½¬æ¢ï¼Œé¿å…æ„å¤–è¡Œä¸º
val x: i32 = 42;
val y: f64 = x as f64;  // æ˜¾å¼è½¬æ¢

// èŒƒå›´æ£€æŸ¥çš„è½¬æ¢
val big: i64 = 1000;
val small = i32::try_from(big).unwrap_or(i32::MAX);

// ä¸ä¼šè‡ªåŠ¨æå‡ç±»å‹
// val result = x + y;  // é”™è¯¯ï¼ä¸èƒ½æ··åˆi32å’Œf64
val result = (x as f64) + y;  // å¿…é¡»æ˜¾å¼è½¬æ¢
```

### æ™ºèƒ½è½¬æ¢ï¼šä¸Šä¸‹æ–‡æ„ŸçŸ¥
```aether
// åœ¨æ˜ç¡®ä¸Šä¸‹æ–‡ä¸­è‡ªåŠ¨è½¬æ¢
fn takes_f64(value: f64) { ... }

val integer = 42;
takes_f64(integer);  // è‡ªåŠ¨è½¬æ¢ä¸ºf64

// ä½†ç®—æœ¯è¿ç®—ä¸­ä¿æŒä¸¥æ ¼
val a: i32 = 10;
val b: i64 = 20;
// val c = a + b;  // é”™è¯¯ï¼å¿…é¡»æ˜¾å¼è½¬æ¢
```

## ç±»å‹ç³»ç»Ÿçš„é«˜çº§ç‰¹æ€§

### å…³è”ç±»å‹ï¼šåœ¨ç‰¹è´¨ä¸­å®šä¹‰ç±»å‹å®¶æ—
```aether
trait Iterator {
    type Item;  // å…³è”ç±»å‹
    
    fn next(&mut self) -> Option<Self::Item>;
}

struct Range {
    current: i32,
    end: i32,
}

impl Iterator for Range {
    type Item = i32;  // æŒ‡å®šå…³è”ç±»å‹
    
    fn next(&mut self) -> Option<i32> {
        if self.current < self.end {
            let result = self.current;
            self.current += 1;
            Some(result)
        } else {
            None
        }
    }
}
```

### æ³›å‹çº¦æŸï¼šé™åˆ¶ç±»å‹å‚æ•°
```aether
// ä½¿ç”¨ç‰¹è´¨çº¦æŸæ³›å‹ç±»å‹
fn largest<T: PartialOrd + Copy>(list: &[T]) -> Option<T> {
    list.iter().max().copied()
}

// ä½¿ç”¨whereå­å¥æé«˜å¯è¯»æ€§
fn complex_function<T, U>(a: T, b: U) -> Result<T, Error>
where 
    T: Display + Clone,
    U: Into<T>,
{
    // ...
}
```

## ç±»å‹ç³»ç»Ÿçš„é”™è¯¯æŒ‡å¯¼

### å‹å¥½çš„ç±»å‹é”™è¯¯ä¿¡æ¯ï¼š
```aether
// å½“ç±»å‹ä¸åŒ¹é…æ—¶
fn expect_string(s: &str) -> usize {
    s.len()
}

val number = 42;
expect_string(number);  // é”™è¯¯ï¼

/*
é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
  --> src/main.aether:15:17
   |
15 | expect_string(number);
   |               ^^^^^^ æœŸæœ› &strï¼Œå®é™…å¾—åˆ° i32
   |
å¸®åŠ©ï¼šè€ƒè™‘ä½¿ç”¨ to_string() è½¬æ¢ï¼š
      expect_string(number.to_string().as_str())
     æˆ–è€…æ£€æŸ¥å‡½æ•°ç­¾åæ˜¯å¦éœ€è¦ä¿®æ”¹
*/
```

### ç”Ÿå‘½å‘¨æœŸé”™è¯¯æŒ‡å¯¼ï¼š
```aether
fn bad_function() -> &str {
    let s = String::from("hello");
    &s  // é”™è¯¯ï¼è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨
}

/*
é”™è¯¯ï¼šè¿”å›äº†å±€éƒ¨å˜é‡çš„å¼•ç”¨
  --> src/main.aether:20:5
   |
20 |     &s
   |     ^^ è¿”å›äº†åœ¨å‡½æ•°å†…åˆ†é…çš„å€¼çš„å¼•ç”¨
   |
å¸®åŠ©ï¼šè€ƒè™‘è¿”å›æ‰€æœ‰æƒè€Œä¸æ˜¯å¼•ç”¨ï¼š
      fn good_function() -> String {
          String::from("hello")
      }
      æˆ–è€…ä½¿ç”¨é™æ€ç”Ÿå‘½å‘¨æœŸï¼š&'static str
*/
```

## å®é™…ä¸šåŠ¡åœºæ™¯ä¸­çš„ç±»å‹åº”ç”¨

### é¢†åŸŸå»ºæ¨¡ç¤ºä¾‹ï¼š
```aether
// ç”µå•†ç³»ç»Ÿçš„ç±»å‹è®¾è®¡
struct Money {
    amount: i64,    // ä»¥åˆ†ä¸ºå•ä½ï¼Œé¿å…æµ®ç‚¹è¯¯å·®
    currency: Currency,
}

enum Currency {
    USD,
    EUR,
    CNY,
}

struct Product {
    id: ProductId,
    name: String,
    price: Money,
    category: Category,
}

enum OrderStatus {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}

// ä½¿ç”¨æ–°ç±»å‹ç¡®ä¿ç±»å‹å®‰å…¨
struct OrderId(u64);
struct CustomerId(u64);
struct ProductId(u64);
```

### APIè®¾è®¡ä¸­çš„ç±»å‹å®‰å…¨ï¼š
```aether
// ä½¿ç”¨ç±»å‹ç³»ç»Ÿé˜²æ­¢APIè¯¯ç”¨
struct DatabaseUrl(String);  // å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ•°æ®åº“URL
struct ApiKey(String);       // å¿…é¡»æ˜¯æ ¼å¼æ­£ç¡®çš„APIå¯†é’¥

struct Config {
    database_url: DatabaseUrl,
    api_key: ApiKey,
    timeout: Duration,
}

// åªèƒ½é€šè¿‡éªŒè¯å‡½æ•°åˆ›å»º
impl DatabaseUrl {
    fn new(url: &str) -> Result<Self, ValidationError> {
        if !is_valid_database_url(url) {
            return Err(ValidationError::InvalidUrl);
        }
        Ok(DatabaseUrl(url.to_string()))
    }
}
```

## ç±»å‹ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–

### é›¶å¤§å°ç±»å‹ï¼ˆZSTï¼‰ï¼š
```aether
// ä¸å ç”¨å†…å­˜çš„ç±»å‹
struct Marker;  // é›¶å¤§å°ç±»å‹
struct PhantomData<T>;  // ç”¨äºæ³›å‹å‚æ•°çš„é›¶å¤§å°ç±»å‹

// åœ¨å®é™…ä»£ç ä¸­çš„åº”ç”¨
struct Set<T> {
    data: Vec<T>,
    _marker: PhantomData<T>,  // ä¸å½±å“å†…å­˜å¸ƒå±€
}
```

### å†…è”ä¼˜åŒ–ï¼š
```aether
// å°ç±»å‹è‡ªåŠ¨å†…è”
struct Point { x: i32, y: i32 }  // 8å­—èŠ‚ï¼Œé€‚åˆå†…è”

fn process_point(p: Point) -> Point {
    Point { x: p.x + 1, y: p.y + 1 }
}

// ç¼–è¯‘å™¨å¯èƒ½å†…è”ä¸ºï¼š
// p.x + 1, p.y + 1 çš„ç›´æ¥æ“ä½œ
```

## ç±»å‹ç³»ç»Ÿè®¾è®¡æ€»ç»“

| ç‰¹æ€§ | AetherLangå®ç° | è®¾è®¡ç†ç”± |
|------|----------------|----------|
| ç±»å‹æ¨å¯¼ | å¼ºå¤§çš„å±€éƒ¨å’Œä¸Šä¸‹æ–‡æ¨æ–­ | å‡å°‘æ ·æ¿ä»£ç ï¼Œæé«˜å¼€å‘æ•ˆç‡ |
| å¯é€‰ç±»å‹ | Option<T>æ›¿ä»£null | ç¼–è¯‘æ—¶å¼ºåˆ¶å¤„ç†ç©ºå€¼æƒ…å†µ |
| é”™è¯¯å¤„ç† | Result<T, E>é›†æˆ | é”™è¯¯ä½œä¸ºä¸€ç­‰å…¬æ°‘ï¼Œå¼ºåˆ¶å¤„ç† |
| ç±»å‹å®‰å…¨ | æ˜¾å¼è½¬æ¢ï¼Œæ— éšå¼æå‡ | é¿å…æ„å¤–è¡Œä¸ºï¼Œä»£ç æ›´å¯é¢„æµ‹ |
| æ³›å‹ç³»ç»Ÿ | ç‰¹è´¨çº¦æŸ+å…³è”ç±»å‹ | å¹³è¡¡è¡¨è¾¾åŠ›ä¸ç¼–è¯‘æ—¶æ£€æŸ¥ |

**æ ¸å¿ƒåˆ›æ–°**ï¼šåœ¨ä¿æŒå¼ºå¤§ç±»å‹å®‰å…¨çš„åŒæ—¶ï¼Œé€šè¿‡æ™ºèƒ½ç±»å‹æ¨å¯¼å’Œå‹å¥½é”™è¯¯ä¿¡æ¯ï¼Œé™ä½å­¦ä¹ æ›²çº¿å’Œä½¿ç”¨æˆæœ¬ã€‚

---

## äº’åŠ¨æŒ‘æˆ˜ï¼šç±»å‹è®¾è®¡ç»ƒä¹ 

```aether
// æŒ‘æˆ˜1ï¼šè®¾è®¡ä¸€ä¸ªå®‰å…¨çš„è´¢åŠ¡è®¡ç®—ç±»å‹ç³»ç»Ÿ
// è¦æ±‚ï¼šé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜ï¼Œé˜²æ­¢è´§å¸å•ä½æ··æ·†
// ä½ çš„è®¾è®¡ï¼š

// æŒ‘æˆ˜2ï¼šä¸ºWeb APIè®¾è®¡ç±»å‹å®‰å…¨çš„è¯·æ±‚/å“åº”ç±»å‹
// è¦æ±‚ï¼šç¼–è¯‘æ—¶æ£€æŸ¥å¿…å¡«å­—æ®µï¼Œè‡ªåŠ¨åºåˆ—åŒ–/ååºåˆ—åŒ–
// ä½ çš„è®¾è®¡ï¼š

// æŒ‘æˆ˜3ï¼šä¼˜åŒ–ä»¥ä¸‹ä»£ç çš„ç±»å‹å®‰å…¨æ€§
fn process_user_input(input: &str) -> String {
    // å½“å‰å®ç°æœ‰æ½œåœ¨çš„ç±»å‹å®‰å…¨é—®é¢˜
    let number = input.parse().unwrap();  // å¯èƒ½panic
    let result = number * 2;
    result.to_string()
}
```

**æ€è€ƒ**ï¼šå¦‚ä½•ç”¨AetherLangçš„ç±»å‹ç³»ç»Ÿæ”¹è¿›è¿™äº›è®¾è®¡ï¼Ÿ

---

**ä¸‹ä¸€èŠ‚é¢„å‘Š**ï¼š  
åŸºç¡€ç±»å‹ç³»ç»Ÿè®¾è®¡å®Œæˆåï¼Œæˆ‘ä»¬å°†æ·±å…¥æ³›å‹ç¼–ç¨‹ã€‚åœ¨[3.2]ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢AetherLangçš„æ³›å‹ç³»ç»Ÿå¦‚ä½•å®ç°ä»£ç å¤ç”¨ä¸ç±»å‹å®‰å…¨çš„å®Œç¾ç»“åˆï¼ŒåŒ…æ‹¬æ³›å‹å‡½æ•°ã€æ³›å‹ç»“æ„ä½“ã€ç‰¹è´¨çº¦æŸç­‰é«˜çº§ç‰¹æ€§ã€‚

> "å¥½çš„ç±»å‹ç³»ç»Ÿåº”è¯¥åƒå¥½çš„äº¤é€šæ ‡å¿—â€”â€”æ¸…æ™°æŒ‡ç¤ºæ–¹å‘ï¼ŒåŠæ—¶è­¦å‘Šå±é™©ï¼Œä½†ä¸ä¼šè¿‡åº¦é™åˆ¶é©¾é©¶è‡ªç”±ã€‚"  
> â€”â€” AetherLangç±»å‹ç³»ç»Ÿè®¾è®¡å“²å­¦