# 4.2 编译时反射与代码生成
**——让编译器成为你的编程助手**

> "编译时反射就像给编译器装上了X光眼镜——它能看透代码的结构，并在编译时做出智能决策。"  
> —— 某位在元编程中发现新大陆的开发者

编译时反射是AetherLang最强大的元编程特性之一。它允许程序在编译时检查类型信息、生成代码，并在不损失性能的情况下提供运行时灵活性。我们的设计目标是让编译时反射既强大又安全。

## 编译时反射设计哲学

### 设计原则：
1. **零成本抽象**：反射信息在编译时处理，无运行时开销
2. **类型安全**：所有生成的代码都经过完整类型检查
3. **渐进暴露**：从简单用例到高级功能的平滑学习曲线
4. **工具友好**：与IDE和调试器深度集成

## 类型反射系统

### 基础类型信息：
```aether
// 编译时获取类型信息
const fn type_info<T>() -> TypeInfo {
    TypeInfo::of::<T>()
}

// 使用示例
const INT_INFO: TypeInfo = type_info::<i32>();
println!("类型名: {}", INT_INFO.name());        // "i32"
println!("大小: {}", INT_INFO.size_of());       // 4
println!("对齐: {}", INT_INFO.align_of());      // 4
println!("是否为数字: {}", INT_INFO.is_numeric()); // true
```

### 结构体反射：
```aether
// 编译时反射结构体信息
#[derive(Reflect)]
struct User {
    name: String,
    age: u32,
    email: String,
}

// 获取结构体元数据
const USER_INFO: StructInfo = User::reflect();
println!("结构体名: {}", USER_INFO.name());
println!("字段数: {}", USER_INFO.fields().len());

// 遍历字段信息
for field in USER_INFO.fields() {
    println!("字段: {} : {}", field.name(), field.type_name());
    println!("偏移量: {}", field.offset());
    println!("是否可空: {}", field.is_nullable());
}
```

## 编译时代码生成

### 派生实现生成：
```aether
// 自定义派生宏
#[derive(Serialize, Deserialize, Clone, Debug)]
struct Product {
    id: u64,
    name: String,
    price: f64,
    in_stock: bool,
}

// 编译时生成的代码示例：
impl Serialize for Product {
    fn to_json(&self) -> String {
        format!(
            r#"{{"id":{},"name":"{}","price":{},"in_stock":{}}}"#,
            self.id, self.name, self.price, self.in_stock
        )
    }
}

impl Deserialize for Product {
    fn from_json(json: &str) -> Result<Self, ParseError> {
        // 自动生成的解析逻辑
        // 基于反射信息动态处理字段
    }
}
```

### 基于反射的Builder模式：
```aether
// 自动生成Builder
#[derive(Builder)]
struct Config {
    host: String,
    port: u16,
    timeout: Duration,
    retries: u32,
}

// 生成的Builder代码
impl Config {
    fn builder() -> ConfigBuilder {
        ConfigBuilder::new()
    }
}

struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<Duration>,
    retries: Option<u32>,
}

impl ConfigBuilder {
    fn new() -> Self {
        Self {
            host: None,
            port: None,
            timeout: None,
            retries: None,
        }
    }
    
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    // ... 其他setter方法
    
    fn build(self) -> Result<Config, BuildError> {
        Ok(Config {
            host: self.host.ok_or(BuildError::MissingField("host"))?,
            port: self.port.ok_or(BuildError::MissingField("port"))?,
            timeout: self.timeout.unwrap_or(Duration::from_secs(30)),
            retries: self.retries.unwrap_or(3),
        })
    }
}

// 使用生成的Builder
val config = Config::builder()
    .host("localhost".to_string())
    .port(8080)
    .timeout(Duration::from_secs(60))
    .build()?;
```

## 过程宏与语法树操作

### 自定义属性宏：
```aether
// 路由属性宏
#[route(path = "/users/:id", method = "GET", auth = required)]
fn get_user(id: u64) -> Result<User, Error> {
    User::find(id)
}

// 宏展开为：
fn get_user(id: u64) -> Result<User, Error> {
    User::find(id)
}

// 同时生成路由注册代码
compile_time! {
    Router::register("/users/:id", "GET", get_user, Auth::Required);
}
```

### 测试框架宏：
```aether
// 测试用例生成
#[test_case]
fn test_user_creation() {
    let user = User::new("Alice", 25);
    assert!(user.validate().is_ok());
}

#[parameterized_test]
#[case("valid@email.com", true)]
#[case("invalid-email", false)]
fn test_email_validation(email: &str, expected: bool) {
    assert_eq!(Email::validate(email), expected);
}

// 编译时生成测试套件
compile_time! {
    TestSuite::add_test("test_user_creation", test_user_creation);
    TestSuite::add_parameterized_test("test_email_validation", test_email_validation);
}
```

## 编译时验证与约束

### 类型约束检查：
```aether
// 编译时验证类型约束
const fn validate_serializable<T: Serialize>() -> bool {
    // 检查T是否实现了Serialize
    has_impl::<T, Serialize>()
}

// 使用示例
const IS_SERIALIZABLE: bool = validate_serializable::<User>();
static_assert!(IS_SERIALIZABLE, "User必须可序列化");

// 或者更简洁的语法
#[require(Serialize)]
fn save_data<T>(data: &T) -> Result<(), Error> {
    // 编译时确保T实现了Serialize
    storage::save(data.to_json())
}
```

### 不变式检查：
```aether
// 编译时检查业务规则
struct Account {
    balance: f64,
}

impl Account {
    fn withdraw(&mut self, amount: f64) {
        invariant!(amount > 0.0, "取款金额必须为正数");
        invariant!(amount <= self.balance, "余额不足");
        
        self.balance -= amount;
    }
}

// 编译时展开为：
impl Account {
    fn withdraw(&mut self, amount: f64) {
        if !(amount > 0.0) {
            panic!("取款金额必须为正数");
        }
        if !(amount <= self.balance) {
            panic!("余额不足");
        }
        
        self.balance -= amount;
    }
}
```

## 领域特定语言（DSL）生成

### 查询DSL生成：
```aether
// 类型安全的SQL查询生成
#[derive(Queryable)]
struct User {
    id: u64,
    name: String,
    email: String,
}

// 编译时生成查询方法
impl User {
    fn select() -> QueryBuilder<User> {
        QueryBuilder::new("users")
    }
}

// 使用生成的DSL
val query = User::select()
    .filter(User::name.eq("Alice"))
    .filter(User::email.like("%@example.com"))
    .order_by(User::id.desc())
    .limit(10);

val users: Vec<User> = query.execute()?;
```

### API客户端生成：
```aether
// 从OpenAPI规范生成类型安全客户端
#[openapi("https://api.example.com/openapi.json")]
mod api {
    // 自动生成的类型和客户端
    struct User { ... }
    struct Product { ... }
    
    trait ApiClient {
        async fn get_user(&self, id: u64) -> Result<User, Error>;
        async fn create_product(&self, product: Product) -> Result<ProductId, Error>;
    }
}

// 使用生成的客户端
val client = ApiClient::new("https://api.example.com");
val user = client.get_user(123).await?;
val product_id = client.create_product(new_product).await?;
```

## 编译时优化与特化

### 基于类型的特化：
```aether
// 编译时为不同类型生成优化版本
trait Processor {
    fn process(&self, data: &[u8]) -> Vec<u8>;
}

// 通用实现
impl<T> Processor for T {
    default fn process(&self, data: &[u8]) -> Vec<u8> {
        // 通用处理逻辑
        data.to_vec()
    }
}

// 为特定类型特化
impl Processor for ImageData {
    fn process(&self, data: &[u8]) -> Vec<u8> {
        // 图像专用优化处理
        optimize_image(data)
    }
}

impl Processor for TextData {
    fn process(&self, data: &[u8]) -> Vec<u8> {
        // 文本专用优化处理
        compress_text(data)
    }
}

// 编译器自动选择最佳实现
fn process_data<T: Processor>(processor: &T, data: &[u8]) -> Vec<u8> {
    processor.process(data)  // 静态分派到特化版本
}
```

### 常量求值与编译时计算：
```aether
// 编译时计算斐波那契数列
const fn fibonacci(n: u32) -> u32 {
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// 编译时计算结果
const FIB_10: u32 = fibonacci(10);  // 55
const FIB_20: u32 = fibonacci(20);  // 6765

// 使用编译时常量
val array = [0u8; FIB_10 as usize];  // 数组大小在编译时确定
```

## 元编程与代码生成工具

### 代码模板引擎：
```aether
// 编译时模板展开
template! {
    fn generated_function($name: ident, $type: ty) {
        fn $name(value: $type) -> $type {
            value * 2
        }
    }
}

// 使用模板生成代码
generated_function!(double_i32, i32);
generated_function!(double_f64, f64);

// 展开为：
fn double_i32(value: i32) -> i32 {
    value * 2
}

fn double_f64(value: f64) -> f64 {
    value * 2
}
```

### AST转换与重写：
```aether
// 自定义语法转换
#[syntax_transform]
fn async_to_sync(async_fn: Ast) -> Ast {
    // 将async函数转换为同步版本
    match async_fn {
        Ast::AsyncFunction { name, params, body } => {
            Ast::Function {
                name,
                params,
                body: transform_await_calls(body),
            }
        }
        _ => async_fn,
    }
}

// 使用转换
#[async_to_sync]
fn original_async_function() -> i32 {
    let result = some_async_call().await;
    result * 2
}

// 转换为：
fn original_async_function() -> i32 {
    let result = some_async_call();  // 移除await
    result * 2
}
```

## 编译时反射的实际应用

### ORM映射生成：
```aether
// 从数据库模式生成类型安全映射
#[derive(Table)]
#[table(name = "users", primary_key = "id")]
struct User {
    #[column(name = "user_id", type = "BIGINT")]
    id: u64,
    
    #[column(name = "user_name", type = "VARCHAR(255)")]
    name: String,
    
    #[column(name = "email_address", type = "VARCHAR(255)")]
    email: String,
}

// 编译时生成：
impl User {
    const TABLE_NAME: &str = "users";
    const PRIMARY_KEY: &str = "user_id";
    
    fn from_row(row: &Row) -> Self {
        User {
            id: row.get::<u64>("user_id"),
            name: row.get::<String>("user_name"),
            email: row.get::<String>("email_address"),
        }
    }
}
```

### 序列化格式优化：
```aether
// 基于类型信息优化序列化
#[derive(Serialize)]
struct OptimizedData {
    #[serialize(compact = true)]  // 使用紧凑格式
    id: u64,
    
    #[serialize(skip_if = "String::is_empty")]  // 空字符串跳过
    name: String,
    
    #[serialize(rename = "created_at")]  // 字段重命名
    created: DateTime,
}

// 生成的序列化代码针对每个字段优化
impl Serialize for OptimizedData {
    fn to_json(&self) -> String {
        let mut json = String::from("{");
        
        // id使用紧凑格式
        json.push_str(&format!("\"id\":{}", self.id));
        
        // 空name跳过
        if !self.name.is_empty() {
            json.push_str(&format!(",\"name\":\"{}\"", self.name));
        }
        
        // 重命名字段
        json.push_str(&format!(",\"created_at\":\"{}\"", self.created));
        
        json.push('}');
        json
    }
}
```

## 编译时反射的性能优化

### 零成本反射：
```aether
// 反射信息在编译时解析，运行时无开销
struct ReflectedCall<T> {
    _phantom: PhantomData<T>,
}

impl<T> ReflectedCall<T> {
    fn call(&self) -> T {
        // 编译时生成的特化代码
        compile_time! {
            generate_optimized_call::<T>()
        }
    }
}

// 编译时生成：
impl ReflectedCall<i32> {
    fn call(&self) -> i32 {
        42  // 编译时计算的结果
    }
}

impl ReflectedCall<String> {
    fn call(&self) -> String {
        "hello".to_string()  // 编译时生成的字符串
    }
}
```

### 内联优化：
```aether
// 小反射操作自动内联
#[inline(always)]
fn get_type_name<T>() -> &'static str {
    std::any::type_name::<T>()
}

// 使用处直接替换为常量
val name = get_type_name::<i32>();
// 编译为：val name = "i32";
```

## 错误处理与调试支持

### 编译时错误诊断：
```aether
// 反射相关的友好错误信息
fn process_reflected_type<T>() {
    // 编译时检查T是否满足条件
    compile_time_assert!(
        has_impl::<T, Debug>(),
        "类型{}必须实现Debug特质",
        type_name::<T>()
    );
    
    // 如果T没有实现Debug，编译错误：
    /*
    错误：编译时断言失败
      --> src/main.aether:15:5
       |
    15 |     compile_time_assert!(...);
       |     ^^^^^^^^^^^^^^^^^^^^^^^^^ 类型`SecretType`必须实现Debug特质
       |
    帮助：为`SecretType`实现`Debug`：
         impl Debug for SecretType {
             fn fmt(&self, f: &mut Formatter) -> Result {
                 write!(f, "SecretType({})", self.value)
             }
         }
    */
}
```

### 反射调试工具：
```aether
// 编译时反射调试宏
#[debug_reflection]
struct User {
    name: String,
    age: u32,
}

// 编译时输出反射信息：
/*
反射调试信息：
结构体: User
大小: 24 字节
对齐: 8 字节
字段:
  - name: String (偏移: 0)
  - age: u32 (偏移: 16)
*/
```

## 编译时反射的边界与限制

### 安全边界：
```aether
// 反射不能绕过访问控制
struct PrivateData {
    private_field: String,  // 私有字段
}

// 即使使用反射，也不能访问私有字段
fn attempt_access() {
    let info = PrivateData::reflect();
    // info.field("private_field")  // 编译错误！
    
    /*
    错误：访问私有字段
      --> src/main.aether:25:25
       |
    25 |     info.field("private_field");
       |                         ^^^^^^^ 字段`private_field`是私有的
    */
}
```

### 编译时与运行时边界：
```aether
// 明确区分编译时和运行时反射
fn process_type<T>() {
    // 编译时反射（零成本）
    const INFO: TypeInfo = type_info::<T>();
    println!("编译时信息: {}", INFO.name());
    
    // 运行时反射（有成本，但更灵活）
    let rt_info = RuntimeTypeInfo::of::<T>();
    println!("运行时信息: {}", rt_info.name());
    
    // 根据需求选择合适的方式
    if NEEDS_DYNAMIC_INFO {
        use_runtime_reflection(rt_info);
    } else {
        use_compile_time_reflection(INFO);
    }
}
```

## 实际业务场景应用

### 配置验证系统：
```aether
// 编译时验证配置结构
#[derive(Config)]
struct AppConfig {
    #[validate(min = 1, max = 65535)]
    port: u16,
    
    #[validate(non_empty)]
    host: String,
    
    #[validate(range = "0.0..1.0")]
    timeout_factor: f64,
}

// 编译时生成验证代码
impl Validate for AppConfig {
    fn validate(&self) -> Result<(), ValidationError> {
        if !(1..=65535).contains(&self.port) {
            return Err(ValidationError::new("port必须在1-65535范围内"));
        }
        if self.host.is_empty() {
            return Err(ValidationError::new("host不能为空"));
        }
        if !(0.0..=1.0).contains(&self.timeout_factor) {
            return Err(ValidationError::new("timeout_factor必须在0.0-1.0范围内"));
        }
        Ok(())
    }
}
```

### API版本兼容性：
```aether
// 编译时检查API兼容性
#[api_version("1.0")]
struct UserV1 {
    name: String,
    age: u32,
}

#[api_version("2.0")]
struct UserV2 {
    name: String,
    age: u32,
    email: String,  // 新增字段
}

// 编译时检查版本迁移
fn migrate_user_v1_to_v2(v1: UserV1) -> UserV2 {
    compile_time_check!(
        is_compatible::<UserV1, UserV2>(),
        "UserV1到UserV2的迁移可能丢失数据"
    );
    
    UserV2 {
        name: v1.name,
        age: v1.age,
        email: String::new(),  // 默认值
    }
}
```

## 编译时反射总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 类型反射 | 编译时类型信息查询 | 零成本，类型安全 |
| 代码生成 | 过程宏和模板 | 减少样板代码，提高一致性 |
| 验证系统 | 编译时约束检查 | 提前发现错误，提高可靠性 |
| 优化特化 | 基于类型信息优化 | 性能最大化 |
| DSL生成 | 领域特定语言 | 提高表达力和开发效率 |

**核心创新**：在保持强大元编程能力的同时，通过编译时保障和友好工具链，使高级特性对普通开发者更加可访问。

---

## 互动挑战：编译时反射设计练习

```aether
// 挑战1：设计一个类型安全的ORM查询生成器
// 要求：编译时验证查询语法，生成最优化的SQL
// 你的设计：

// 挑战2：实现一个配置验证框架
// 要求：编译时检查配置有效性，生成验证代码
// 你的设计：

// 挑战3：优化以下存在反射问题的代码
fn dynamic_serialization(data: &dyn Any) -> String {
    // 当前实现使用运行时类型检查，性能较差
    if let Some(num) = data.downcast_ref::<i32>() {
        format!("数字: {}", num)
    } else if let Some(text) = data.downcast_ref::<String>() {
        format!("文本: {}", text)
    } else {
        "未知类型".to_string()
    }
}
```

**思考**：如何用编译时反射优化这个函数？

---

**下一节预告**：  
编译时反射设计完成后，我们将探索AetherLang的异步编程模型。在[4.3]中，我们将介绍基于async/await的现代异步编程，以及如何实现高性能的并发处理。

> "好的编译时反射应该像好的预言——它能看到未来（运行时）的情况，并在现在（编译时）做出最佳决策。"  
> —— AetherLang编译时反射设计哲学