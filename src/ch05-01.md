# 5.1 包管理与依赖管理
**——构建可复用、可维护的软件生态系统**

> "包管理器就像编程语言的'应用商店'——让代码复用变得简单，让依赖地狱成为历史。"  
> —— 某位在依赖冲突中挣扎多年的全栈开发者

包管理是现代编程语言生态系统的核心。AetherLang的包管理系统设计目标是：**安全、高效、可预测**。我们既要支持大规模的代码复用，又要避免依赖冲突和版本混乱。

## 包管理系统设计哲学

### 设计原则：
1. **语义化版本**：明确的版本约定和兼容性规则
2. **可重现构建**：确保每次构建结果一致
3. **安全第一**：依赖验证和漏洞扫描
4. **性能优先**：快速依赖解析和下载

## 包声明与元数据

### 包清单文件（aether.toml）：
```toml
# aether.toml - AetherLang包清单
[package]
name = "my-library"           # 包名：小写字母、数字、连字符
version = "0.1.0"             # 语义化版本：主版本.次版本.修订版本
authors = ["Alice <alice@example.com>", "Bob <bob@example.com>"]
description = "一个优秀的AetherLang库"
license = "MIT OR Apache-2.0" # SPDX许可证标识
repository = "https://github.com/user/my-library"
readme = "README.md"
keywords = ["网络", "异步", "高性能"]
categories = ["网络编程"]

# 依赖声明
[dependencies]
# 来自官方仓库的依赖
serde = "1.0"                 # 自动选择1.x.x的最新版本
tokio = { version = "1.0", features = ["full"] }
http = "3.0"

# 来自Git仓库的依赖
redis = { git = "https://github.com/aetherlang/redis.git", branch = "main" }

# 路径依赖（本地开发）
my-utils = { path = "../my-utils" }

# 可选依赖
[dependencies.advanced-features]
optional = true
advanced-math = "2.0"

# 开发依赖（仅用于测试和示例）
[dev-dependencies]
test-utils = "0.5"
mock-server = "0.3"

# 构建依赖（编译时工具）
[build-dependencies]
code-generator = "0.1"

# 特性标志（条件编译）
[features]
default = ["basic"]           # 默认启用的特性
basic = []                    # 基础特性
advanced = ["advanced-math"]  # 高级特性（包含可选依赖）
```

## 依赖解析与版本管理

### 语义化版本解析：
```aether
// 版本约束语法示例
dependencies = {
    // 兼容性版本
    "library-a" = "1.2.3",     // 严格匹配1.2.3
    "library-b" = "^1.2.3",    // 兼容1.2.3（1.x.x，x >= 2.3）
    "library-c" = "~1.2.3",    // 近似版本（1.2.x，x >= 3）
    "library-d" = ">=1.2.3, <2.0.0",  // 范围约束
    
    // 预发布版本
    "library-e" = "2.0.0-alpha.1",  // 特定预发布版本
    "library-f" = "2.0.0-beta",    // 所有beta版本
    
    // 通配符版本
    "library-g" = "*",          // 任何版本（谨慎使用）
    "library-h" = "1.*",        // 任何1.x版本
}
```

### 依赖图解析算法：
```aether
// 依赖解析器实现
class DependencyResolver {
    fn resolve(dependencies: Map<String, VersionReq>) -> Result<Resolution, ResolveError> {
        // 使用SAT求解器进行版本解析
        let solver = SatSolver::new();
        
        for (name, req) in dependencies {
            let available_versions = registry.get_versions(name);
            let candidates = available_versions.filter(|v| req.matches(v));
            
            solver.add_package(name, candidates);
        }
        
        // 添加冲突检测
        solver.add_conflict_rules();
        
        // 求解最优版本组合
        match solver.solve() {
            Some(solution) => Ok(Resolution::new(solution)),
            None => Err(ResolveError::UnresolvableDependencies),
        }
    }
}
```

## 构建系统与任务管理

### 构建脚本（build.aether）：
```aether
// build.aether - 自定义构建脚本
import aether_build::*;

fn main() {
    // 代码生成任务
    task!("generate-protobuf", || {
        println!("生成Protobuf代码...");
        Protobuf::compile("proto/**/*.proto", "src/generated");
    });
    
    // 资源处理任务
    task!("bundle-assets", || {
        Assets::bundle("assets/", "dist/");
    });
    
    // 自定义编译任务
    task!("optimize-wasm", || {
        if target::is_wasm() {
            WasmOpt::optimize("target/wasm/app.wasm");
        }
    });
    
    // 构建前任务依赖
    before_build("generate-protobuf", "bundle-assets");
    after_build("optimize-wasm");
}
```

### 任务运行器集成：
```aether
// 命令行任务执行
aether run build          # 运行构建
aether run test           # 运行测试
aether run bench          # 运行基准测试
aether run doc            # 生成文档
aether run clean          # 清理构建产物

// 自定义任务
aether run generate-protobuf
aether run bundle-assets

// 任务组合
aether run build test doc  # 依次执行多个任务
```

## 包发布与分发

### 包发布流程：
```aether
// 发布前的验证
aether publish --dry-run    # 干运行，检查包是否可发布

// 发布检查清单：
// 1. 所有测试通过
// 2. 文档完整
// 3. 许可证正确
// 4. 没有大文件
// 5. 版本号遵循语义化版本

// 实际发布
aether publish --registry crates.aetherlang.org
```

### 版本发布策略：
```aether
// 自动化版本管理
fn determine_next_version(current: Version, changes: ChangeSet) -> Version {
    match changes {
        ChangeSet::Breaking => current.increment_major(),
        ChangeSet::Features => current.increment_minor(),
        ChangeSet::Fixes => current.increment_patch(),
    }
}

// 变更日志自动生成
fn generate_changelog(version: Version, commits: Vec<Commit>) -> String {
    let mut changelog = format!("## {} ({})\n\n", version, Date::today());
    
    for commit in commits.group_by_type() {
        changelog.push_str(&format!("### {}\n", commit.type));
        for msg in commit.messages {
            changelog.push_str(&format!("- {}\n", msg));
        }
        changelog.push_str("\n");
    }
    
    changelog
}
```

## 安全与验证

### 依赖漏洞扫描：
```aether
// 安全审计集成
fn audit_dependencies() -> AuditReport {
    let scanner = VulnerabilityScanner::new();
    
    // 检查已知漏洞
    let vulnerabilities = scanner.scan_lockfile("aether.lock");
    
    // 检查许可证兼容性
    let license_issues = LicenseChecker::check_compatibility();
    
    AuditReport {
        vulnerabilities,
        license_issues,
        recommendations: generate_fixes(),
    }
}

// 自动安全更新
fn update_dependencies() -> Result<(), UpdateError> {
    let outdated = check_outdated();
    
    for (name, current, latest) in outdated {
        if is_security_update(latest) {
            // 自动应用安全更新
            update_package(name, latest)?;
            println!("安全更新: {} {} -> {}", name, current, latest);
        }
    }
    
    generate_lockfile()
}
```

### 供应链安全：
```aether
// 依赖来源验证
fn verify_dependency_integrity(package: &Package) -> Result<(), VerificationError> {
    // 检查数字签名
    if !package.verify_signature() {
        return Err(VerificationError::InvalidSignature);
    }
    
    // 检查哈希值
    let expected_hash = registry.get_hash(package.name, package.version);
    if package.compute_hash() != expected_hash {
        return Err(VerificationError::HashMismatch);
    }
    
    // 检查构建可重现性
    if !package.is_reproducible() {
        return Err(VerificationError::NotReproducible);
    }
    
    Ok(())
}
```

## 工作区与多包管理

### 工作区配置：
```toml
# workspace.aether.toml - 工作区根配置
[workspace]
members = [
    "crates/core",          # 核心库
    "crates/http",          # HTTP库  
    "crates/database",      # 数据库库
    "examples/*",           # 所有示例
    "benchmarks/*",         # 基准测试
]

# 工作区级依赖（所有成员共享）
[dependencies]
shared-utils = { path = "crates/utils" }
common-traits = { path = "crates/traits" }

# 工作区特性
[workspace.features]
default = ["full"]
full = ["core/advanced", "http/ssl", "database/postgres"]
minimal = ["core/basic"]
```

### 工作区任务管理：
```aether
// 工作区级构建脚本
task!("workspace-build", || {
    // 并行构建所有成员
    workspace::parallel_build(|member| {
        member.build().await
    }).await;
});

task!("workspace-test", || {
    // 运行所有测试
    workspace::run_tests().await;
});

task!("workspace-publish", || {
    // 按依赖顺序发布所有包
    workspace::publish_in_order().await;
});
```

## 跨平台与条件编译

### 平台特定依赖：
```toml
# 平台条件依赖
[target.'cfg(unix)'.dependencies]
unix-sockets = "1.0"

[target.'cfg(windows)'.dependencies]
win32-api = "2.0"

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"

# 特性条件依赖
[dependencies]
# 默认特性包含基础实现
default-features = false
basic-impl = "1.0"

[features]
accelerated = ["gpu-accel"]  # GPU加速特性

[target.'cfg(feature = "accelerated")'.dependencies]
gpu-accel = "3.0"
```

### 条件编译配置：
```aether
// 构建时条件编译
fn configure_build() {
    // 根据目标平台配置
    if target::is_windows() {
        println!("配置Windows特定设置...");
        set_build_flag("WINDOWS");
    }
    
    // 根据特性配置
    if has_feature("accelerated") {
        println!("启用GPU加速...");
        link_library("cuda");
    }
    
    // 环境变量配置
    if env::var("AETHER_DEBUG").is_ok() {
        set_optimization_level(0);  // 调试构建
    }
}
```

## 性能优化

### 增量编译：
```aether
// 智能增量编译系统
struct IncrementalCompiler {
    cache: CompilationCache,
    dependency_graph: DependencyGraph,
}

impl IncrementalCompiler {
    fn compile_package(&self, package: &Package) -> CompilationResult {
        // 检查缓存
        if let Some(cached) = self.cache.get(package) {
            if !cached.is_stale() {
                return cached.result.clone();
            }
        }
        
        // 增量编译
        let changed_files = self.detect_changes(package);
        let result = self.compile_changed(changed_files);
        
        // 更新缓存
        self.cache.update(package, result.clone());
        result
    }
}
```

### 并行构建优化：
```aether
// 最大化并行构建
async fn parallel_build_optimized(packages: Vec<Package>) {
    let graph = build_dependency_graph(&packages);
    let parallel_groups = graph.parallelizable_groups();
    
    // 并行构建独立包组
    let tasks = parallel_groups.into_iter().map(|group| {
        spawn(async move {
            for package in group {
                package.build().await;
            }
        })
    });
    
    join_all(tasks).await;
}
```

## 开发者体验优化

### 智能依赖推荐：
```aether
// 基于使用模式的依赖推荐
fn recommend_dependencies(project_type: ProjectType, existing_deps: &[String]) -> Vec<Recommendation> {
    let mut recommendations = Vec::new();
    
    match project_type {
        ProjectType::WebServer => {
            if !existing_deps.contains("http") {
                recommendations.push(Recommendation {
                    name: "http".to_string(),
                    reason: "Web服务器需要HTTP库".to_string(),
                    popularity: 95,  // 流行度分数
                });
            }
        }
        ProjectType::CliTool => {
            // CLI工具特定推荐
        }
        // ... 其他项目类型
    }
    
    recommendations.sort_by_key(|r| -r.popularity);
    recommendations
}
```

### 交互式依赖管理：
```aether
// 交互式依赖添加
aether add serde        # 添加最新版本
aether add serde@1.0    # 添加特定版本
aether add --dev pytest # 添加开发依赖
aether add --feature advanced redis # 添加特性依赖

// 交互式依赖更新
aether update           # 更新所有依赖
aether update serde     # 更新特定依赖
aether update --major   # 更新主版本（可能破坏兼容性）

// 依赖分析
aether tree             # 显示依赖树
aether why serde        # 显示为什么依赖serde
aether outdated         # 显示过时的依赖
```

## 生态系统集成

### IDE集成：
```aether
// 语言服务器协议支持
struct AetherLanguageServer {
    package_manager: PackageManager,
    dependency_analyzer: DependencyAnalyzer,
}

impl AetherLanguageServer {
    fn on_document_change(&self, uri: &str, content: &str) {
        // 实时依赖分析
        let imports = extract_imports(content);
        let missing_deps = self.find_missing_dependencies(imports);
        
        // 提供自动补全建议
        self.suggest_dependencies(missing_deps);
    }
}
```

### CI/CD集成：
```aether
// 持续集成配置
task!("ci-pipeline", || {
    // 安装依赖
    aether install --locked;  # 使用锁文件确保一致性
    
    // 运行检查
    aether check;            # 编译检查
    aether test;             # 测试
    aether audit;           # 安全审计
    aether bench;           # 性能基准
    
    // 质量门控
    if test_coverage() < 80.0 {
        panic!("测试覆盖率低于80%");
    }
    
    if has_vulnerabilities() {
        panic!("存在安全漏洞");
    }
});
```

## 包管理系统总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 语义化版本 | 严格的版本约束 | 避免依赖冲突，保证兼容性 |
| 依赖解析 | SAT求解器算法 | 最优版本选择，快速解析 |
| 安全审计 | 漏洞数据库集成 | 提前发现安全问题 |
| 工作区支持 | 多包项目管理 | 大型项目高效管理 |
| 条件编译 | 平台特性支持 | 跨平台兼容性 |

**核心创新**：在保持强大功能的同时，通过智能推荐和安全保障，让依赖管理变得简单可靠。

---

## 互动挑战：包管理设计练习

```aether
// 挑战1：设计一个monorepo依赖管理策略
// 要求：支持数百个相互依赖的包，快速增量编译，版本一致性
// 你的设计：

// 挑战2：实现一个安全的供应链验证系统
// 要求：验证依赖来源，防止供应链攻击，支持审计追踪
// 你的设计：

// 挑战3：优化以下存在依赖问题的项目
/*
当前问题：
- 依赖版本冲突（libA需要serde 1.0，libB需要serde 2.0）
- 循环依赖（pkg1 -> pkg2 -> pkg1）
- 未使用的依赖（项目声明了但未使用的库）
*/

// 你的解决方案：
```

**思考**：如何用AetherLang的包管理系统解决这些常见问题？

---

**下一节预告**：  
包管理系统设计完成后，我们将探索AetherLang的测试框架。在[5.2]中，我们将介绍单元测试、集成测试、基准测试等完整的测试生态系统。

> "好的包管理应该像好的物流系统——让正确的依赖在正确的时间到达正确的位置，不会丢失也不会冲突。"  
> —— AetherLang包管理设计哲学