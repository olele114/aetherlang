# 5.3 文档系统：代码与文档的完美结合
**——让文档成为开发流程的自然部分**

> "文档是写给未来的自己的信——好的文档让你在六个月后还能理解当时的代码。"  
> —— 某位在遗留代码中挣扎的开发者

AetherLang的文档系统旨在让编写和维护文档变得简单而自然。我们通过内置的文档工具、示例代码自动测试和可交互的文档，确保文档始终与代码同步。

## 文档系统设计哲学

### 设计原则：
1. **文档即代码**：文档与源代码放在一起，同步维护
2. **示例即测试**：文档中的示例代码可自动测试，确保正确性
3. **丰富呈现**：支持多种输出格式（HTML、PDF、EPUB等）
4. **易于编写**：使用Markdown等轻量级标记，支持代码抽取

## 文档注释语法

### 基础文档注释：
```aether
/// 计算两个数的和
/// 
/// # 示例
/// ```
/// let result = add(2, 3);
/// assert_eq!(result, 5);
/// ```
/// 
/// # 参数
/// - `a`: 第一个加数
/// - `b`: 第二个加数
/// 
/// # 返回
/// 返回两个参数的和
/// 
/// # 注意
/// 此函数不会处理溢出，如果需要溢出检查，请使用`add_checked`
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### 结构体和枚举的文档：
```aether
/// 表示一个二维点
/// 
/// # 示例
/// ```
/// let point = Point { x: 5.0, y: 10.0 };
/// println!("点在 ({}, {})", point.x, point.y);
/// ```
struct Point {
    /// X坐标
    x: f64,
    /// Y坐标
    y: f64,
}

/// 表示操作结果的枚举
/// 
/// # 变体
/// - `Success`: 操作成功，包含结果值
/// - `Failure`: 操作失败，包含错误信息
enum Result<T, E> {
    Success(T),
    Failure(E),
}
```

### 模块级文档：
```aether
//! 数学计算库
//! 
//! 这个库提供了基本的数学运算函数，包括：
//! - 算术运算
//! - 几何计算
//! - 统计分析
//! 
//! # 使用示例
//! ```
//! use math_lib::add;
//! 
//! let sum = add(2, 3);
//! ```

mod math_lib {
    // ... 模块内容
}
```

## 文档测试（Doctests）

### 可测试的文档示例：
```aether
/// 计算阶乘
/// 
/// # 示例
/// ```
/// assert_eq!(factorial(0), 1);
/// assert_eq!(factorial(1), 1);
/// assert_eq!(factorial(5), 120);
/// ```
/// 
/// # 参数
/// - `n`: 非负整数
/// 
/// # 返回
/// n的阶乘
/// 
/// # 异常
/// 如果n为负数，会panic
/// ```
/// ⚠️ 以下测试会失败
/// ```should_panic
/// factorial(-1);
/// ```
fn factorial(n: u32) -> u32 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}
```

### 隐藏文档测试的辅助代码：
```aether
/// 设置一个复杂的计算
/// 
/// # 示例
/// ```
/// # // 以#开头的行不会出现在文档中，但会在测试中运行
/// # let data = vec![1, 2, 3, 4, 5];
/// let result = complex_calculation(data);
/// assert!(result > 0);
/// ```
fn complex_calculation(data: Vec<i32>) -> i32 {
    // ... 复杂实现
}
```

## 文档生成与定制

### 生成文档：
```bash
# 生成HTML文档
aether doc

# 生成文档并打开浏览器
aether doc --open

# 生成文档包含私有项
aether doc --document-private-items

# 持续生成文档（监听文件变化）
aether doc --watch
```

### 文档配置（aether.toml）：
```toml
[package]
name = "my-library"
version = "0.1.0"

# 文档生成配置
[doc]
theme = "dark"           # 主题：dark, light, custom
default-language = "aether"  # 代码块默认语言
mathjax-support = true   # 启用数学公式支持
edit-url = "https://github.com/user/repo/edit/main/{path}"  # 编辑链接

# 文档输出配置
[doc.output]
format = "html"          # 输出格式：html, pdf, epub
directory = "target/doc"  # 输出目录
include-private = false   # 是否包含私有项
```

### 自定义文档主题：
```aether
// 自定义CSS主题
/* docs/theme.css */
:root {
    --primary-color: #3498db;
    --background-color: #2c3e50;
    --text-color: #ecf0f1;
}

/* 应用到生成的文档 */
aether doc --theme docs/theme.css
```

## 高级文档特性

### 文档特性标志：
```aether
/// 异步处理函数
/// 
/// # 示例
/// ## 基本用法
/// ```
/// let result = process_data(data).await;
/// ```
/// 
/// ## 高级用法（需要启用`advanced`特性）
/// ```aether
/// #[cfg(feature = "advanced")]
/// async fn advanced_usage() {
///     let result = process_data_with_retry(data, 3).await;
/// }
/// ```
#[cfg(feature = "advanced")]
async fn process_data_with_retry(data: Data, retries: u32) -> Result<Data, Error> {
    // ... 实现
}
```

### 跨文档链接：
```aether
/// 使用[`add`]函数进行加法运算
/// 
/// 更多数学运算参见[`math`]模块
/// 
/// [`add`]: fn@add
/// [`math`]: mod@math
fn calculator() {
    // ...
}

/// 指向其他项目的文档
/// 
/// 参见[`serde`]库的序列化功能
/// 
/// [`serde`]: https://serde.rs
fn external_reference() {
    // ...
}
```

### 文档搜索集成：
```aether
//! 支持全文搜索的文档
//! 
//! 文档生成器会自动索引所有公共API，提供即时搜索功能

/// 一个具有搜索关键词的函数
/// 
/// 这个函数会出现在搜索"计算"、"加法"等关键词的结果中
fn calculate_addition(a: i32, b: i32) -> i32 {
    a + b
}
```

## 文档质量工具

### 文档覆盖率检查：
```bash
# 检查文档覆盖率
aether doc-coverage

# 输出示例：
# 文档覆盖率报告：
# - 模块: 100% (5/5)
# - 函数: 85% (17/20)
# - 结构体: 90% (9/10)
# - 总体覆盖率: 88%

# 设置覆盖率阈值
aether doc-coverage --min 80   # 低于80%则失败
```

### 文档链接检查：
```bash
# 检查文档中的链接是否有效
aether doc-check-links

# 检查内部链接和外部链接
aether doc-check-links --external
```

### 文档风格检查：
```aether
// 文档Lint工具
#![warn(missing_docs)]          // 警告缺少文档
#![warn(rustdoc::broken_intra_doc_links)]  // 警告损坏的内部链接
#![warn(rustdoc::invalid_codeblock_attributes)]  // 警告代码块属性错误
```

## 交互式文档

### 可运行的代码示例：
```aether
/// 可交互的示例
/// 
/// ## 尝试运行
/// 点击"运行"按钮执行代码：
/// ```aether runnable
/// fn main() {
///     let result = add(2, 3);
///     println!("2 + 3 = {}", result);
/// }
/// ```
/// 
/// ## 可编辑的示例
/// 点击"编辑"按钮修改代码：
/// ```aether editable
/// fn main() {
///     let name = "AetherLang";
///     println!("Hello, {}!", name);
/// }
/// ```
```

### 集成Playground：
```aether
/// 在Playground中尝试
/// 
/// ```aether playground
/// use my_lib::add;
/// 
/// fn main() {
///     println!("{}", add(5, 10));
/// }
/// ```
/// 
/// https://play.aetherlang.org
```

## 多语言文档

### 国际化支持：
```aether
/// 计算两个数的和
/// 
/// # English
/// Calculates the sum of two numbers
/// 
/// # 中文
/// 计算两个数的和
/// 
/// # Español
/// Calcula la suma de dos números
#[doc(lang = "en", "zh", "es")]
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### 多语言文档生成：
```bash
# 生成中文文档
aether doc --lang zh

# 生成所有支持语言的文档
aether doc --all-languages

# 文档配置支持多语言
[doc.languages]
en = "docs/en"
zh = "docs/zh"
es = "docs/es"
```

## 文档部署与集成

### 持续集成文档部署：
```aether
// .aether-ci.aether
pipeline! {
    name: "文档部署",
    
    steps: [
        step!("生成文档", || {
            aether doc --all-features
        }),
        
        step!("部署到GitHub Pages", || {
            deploy_docs_to_github_pages("target/doc")
        })
    ],
    
    triggers: [
        trigger::on_release(),  // 发布时触发
        trigger::on_doc_change()  // 文档变更时触发
    ]
}
```

### 与README集成：
```aether
//! 库的主文档
//! 
//! 这个文件的内容会自动显示在crate的README中

// 从README.md文件导入内容
#![doc = include_str!("../README.md")]

// 库的具体实现...
```

## 智能文档功能

### 自动API文档生成：
```aether
//! 自动生成的API文档
//! 
//! 基于代码结构自动生成详细的API参考

/// # 自动文档特性
/// 
/// ## 类型信息
/// - **类型名**: `User`
/// - **大小**: 24字节
/// - **对齐**: 8字节
/// 
/// ## 方法列表
/// - `new(name: String, age: u32) -> User`
/// - `name(&self) -> &str`
/// - `age(&self) -> u32`
/// - `is_adult(&self) -> bool`
/// 
/// ## 实现的特质
/// - `Debug`, `Clone`, `Serialize`, `Deserialize`
#[derive(Debug, Clone, Serialize, Deserialize)]
struct User {
    name: String,
    age: u32,
}

impl User {
    /// 创建新用户
    pub fn new(name: String, age: u32) -> Self {
        User { name, age }
    }
    
    /// 获取用户名
    pub fn name(&self) -> &str {
        &self.name
    }
    
    /// 获取用户年龄
    pub fn age(&self) -> u32 {
        self.age
    }
    
    /// 检查是否为成年人
    pub fn is_adult(&self) -> bool {
        self.age >= 18
    }
}
```

### 代码示例提取：
```aether
/// 从源代码中提取示例
/// 
/// 以下示例是从测试文件中自动提取的：
/// 
/// ```aether example_from="tests/user_test.aether"
/// // 自动提取的测试代码
/// fn test_user_creation() {
///     let user = User::new("Alice", 25);
///     assert_eq!(user.name(), "Alice");
///     assert!(user.is_adult());
/// }
/// ```
/// 
/// 示例保持同步，当测试文件更新时，文档也会自动更新。
```

### 变更日志集成：
```aether
//! 版本变更记录
//! 
//! ## 版本 0.2.0 (2024-01-15)
//! ### 新增
//! - 添加了`User::is_adult`方法
//! - 支持JSON序列化
//! 
//! ### 变更
//! - `User::new`现在接受`String`而不是`&str`
//! 
//! ### 修复
//! - 修复了年龄验证逻辑
//! 
//! 完整的变更历史参见CHANGELOG.md

#![doc = include_changelog!("../CHANGELOG.md")]
```

## 文档分析工具

### 文档质量评分：
```bash
# 生成文档质量报告
aether doc-quality

# 输出示例：
# 文档质量报告：
# - 完整性: 92% ✅
# - 示例覆盖率: 85% ⚠️
# - 链接有效性: 100% ✅
# - 可读性评分: 78/100 ⚠️
# - 总体评分: B+
```

### 文档更新提醒：
```aether
// 当API变更时检测文档是否需要更新
#[doc(check_on_change)]
fn calculate_interest(principal: f64, rate: f64, years: u32) -> f64 {
    principal * (1.0 + rate).powf(years as f64)
}

// 如果函数签名变更但文档未更新，编译时会警告：
// 警告: 函数签名已变更，但文档未更新
//   --> src/finance.aether:15:1
//    |
// 15 | fn calculate_interest(principal: f64, rate: f64, years: u32, compounding: u32) -> f64 {
//    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//    |
// 帮助: 请更新文档以反映新的参数 `compounding`
```

## 可视化文档

### 图表生成：
```aether
/// 数据库连接池
/// 
/// ## 架构图
/// 
/// ```chart
/// graph TD
///     A[客户端] --> B[连接池]
///     B --> C[数据库连接1]
///     B --> D[数据库连接2]
///     B --> E[数据库连接3]
/// ```
/// 
/// ## 时序图
/// 
/// ```sequence
/// 客户端->连接池: 请求连接
/// 连接池->数据库: 获取连接
/// 数据库-->连接池: 返回连接
/// 连接池-->客户端: 提供连接
/// 客户端->数据库: 执行查询
/// 数据库-->客户端: 返回结果
/// ```
struct ConnectionPool {
    // ... 实现
}
```

### 状态机文档：
```aether
/// 订单状态机
/// 
/// ## 状态转换图
/// 
/// ```state_machine
/// [*] --> Pending : 创建订单
/// Pending --> Paid : 支付成功
/// Paid --> Shipped : 发货
/// Shipped --> Delivered : 送达
/// Pending --> Cancelled : 取消订单
/// Paid --> Cancelled : 退款
/// ```
enum OrderStatus {
    Pending,
    Paid,
    Shipped,
    Delivered,
    Cancelled,
}
```

## 文档系统总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 文档注释 | 三重斜杠`///` | 简单直观，与代码紧密集成 |
| 文档测试 | 自动测试示例代码 | 确保文档示例的正确性 |
| 多格式输出 | HTML、PDF、EPUB | 满足不同阅读需求 |
| 国际化 | 多语言文档支持 | 面向全球开发者 |
| 质量工具 | 覆盖率、链接检查 | 保持文档高质量 |
| 交互式文档 | 可运行示例 | 提供实践学习体验 |

**核心创新**：通过深度集成测试、交互式示例和自动化工具，让文档成为开发流程中活跃的一部分，而不是事后补充。

---

## 互动挑战：文档系统设计练习

```aether
// 挑战1：设计一个API变更时的文档同步机制
// 要求：当函数签名变更时，自动检测文档是否需要更新
// 你的设计：

// 挑战2：实现一个可视化复杂数据结构的文档工具
// 要求：为复杂类型生成图表和交互式示例
// 你的设计：

// 挑战3：改进以下存在文档问题的代码
/// 计算函数
fn calculate(a: i32, b: i32) -> i32 {
    a + b  // 实际是加法，但文档没说清楚
}

/// 处理数据
/// 
/// # 示例
/// ```
/// process_data(data);  // 示例缺少断言，不知道预期行为
/// ```
fn process_data(data: Data) -> Result<(), Error> {
    // ...
}
```

**思考**：如何用AetherLang的文档系统改进这些文档？

---

**下一章预告**：  
文档系统设计完成后，我们将探索AetherLang的包管理和分发系统。在[第6章]中，我们将介绍如何打包、发布和分发AetherLang库。

> "好的文档应该像好的地图——清晰指引方向，标注重要地标，让旅行者不会迷路。"  
> —— AetherLang文档系统设计哲学