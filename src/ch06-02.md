# 6.2 跨平台支持：一次编写，到处运行
**——让代码无缝运行在任何设备上**

> "跨平台就像会说多种语言的翻译官——让同一份代码在不同环境中都能完美工作。"  
> —— 某位在平台兼容性问题上找到通用解决方案的工程师

跨平台支持是现代编程语言的核心竞争力。AetherLang的设计目标是实现真正的"一次编写，到处运行"，同时不损失性能或平台特定优化。我们的解决方案既要通用又要精确。

## 跨平台设计哲学

### 设计原则：
1. **零抽象惩罚**：跨平台API不产生运行时开销
2. **平台特性利用**：允许访问平台特定功能
3. **渐进暴露复杂度**：从简单用例到高级控制的平滑过渡
4. **编译时验证**：在编译时捕获平台不兼容问题

## 目标平台抽象层

### 平台抽象架构：
```aether
// 平台抽象层设计
abstract platform TargetPlatform {
    // 操作系统家族
    enum OperatingSystem {
        Windows,
        Linux,
        macOS,
        iOS,
        Android,
        FreeBSD,
        // 其他Unix变种
    }
    
    // 处理器架构
    enum Architecture {
        X86_64,
        AArch64,      // ARM64
        RiscV64,
        Wasm32,       // WebAssembly
        // 其他架构
    }
    
    // 运行时环境
    enum Environment {
        Native,       // 原生可执行文件
        Browser,     // Web浏览器
        NodeJS,      // Node.js环境
        Embedded,    // 嵌入式系统
    }
}
```

### 条件编译支持：
```aether
// 基于平台的条件编译
fn platform_specific_function() {
    // 操作系统特定代码
    #[cfg(target_os = "windows")]
    {
        windows_specific_implementation();
    }
    
    #[cfg(target_os = "linux")]
    {
        linux_specific_implementation();
    }
    
    #[cfg(target_os = "macos")]
    {
        macos_specific_implementation();
    }
    
    // 架构特定优化
    #[cfg(target_arch = "x86_64")]
    {
        use_x86_64_intrinsics();
    }
    
    #[cfg(target_arch = "aarch64")]
    {
        use_arm_neon_intrinsics();
    }
    
    // 组合条件
    #[cfg(all(target_os = "linux", target_arch = "x86_64"))]
    {
        linux_x86_64_optimized_implementation();
    }
}

// 条件编译的常量
const MAX_PATH_LENGTH: usize = {
    #[cfg(windows)] { 260 }
    #[cfg(unix)] { 1024 }
    #[cfg(wasm)] { 512 }
};
```

## 统一文件系统API

### 跨平台路径处理：
```aether
// 统一路径类型
struct Path {
    inner: PathBuf,
}

impl Path {
    // 平台无关的路径构造
    fn new<S: AsRef<str>>(path: S) -> Self {
        let normalized = Self::normalize_separators(path.as_ref());
        Path { inner: PathBuf::from(normalized) }
    }
    
    // 标准化路径分隔符
    fn normalize_separators(path: &str) -> String {
        if cfg!(windows) {
            path.replace('/', '\\')
        } else {
            path.replace('\\', '/')
        }
    }
    
    // 获取平台特定的路径表示
    fn to_platform_string(&self) -> String {
        if cfg!(windows) {
            self.inner.to_string_lossy().replace('/', '\\')
        } else {
            self.inner.to_string_lossy().replace('\\', '/')
        }
    }
}

// 使用示例
val config_path = Path::new("config/app.json");
println!("路径: {}", config_path.to_platform_string());
// Windows: "config\app.json"
// Unix: "config/app.json"
```

### 文件系统操作抽象：
```aether
// 统一文件系统API
trait FileSystem {
    async fn read_file(path: &Path) -> Result<Vec<u8>, IoError>;
    async fn write_file(path: &Path, data: &[u8]) -> Result<(), IoError>;
    async fn file_exists(path: &Path) -> bool;
    async fn create_dir(path: &Path) -> Result<(), IoError>;
    
    // 平台特定的扩展
    #[cfg(unix)]
    fn get_unix_permissions(&self) -> UnixPermissions;
    
    #[cfg(windows)]
    fn get_windows_attributes(&self) -> WindowsFileAttributes;
}

// 通用实现
impl FileSystem for StdFileSystem {
    async fn read_file(path: &Path) -> Result<Vec<u8>, IoError> {
        #[cfg(not(wasm))]
        {
            tokio::fs::read(path.to_platform_string()).await
        }
        
        #[cfg(wasm)]
        {
            // WebAssembly环境使用浏览器API
            wasm_fs::read_file(path).await
        }
    }
}
```

## 网络编程跨平台支持

### 统一网络API：
```aether
// 跨平台网络抽象
abstract network NetworkStack {
    // 通用网络操作
    async fn tcp_connect(addr: SocketAddr) -> Result<TcpStream, IoError>;
    async fn tcp_listen(addr: SocketAddr) -> Result<TcpListener, IoError>;
    async fn udp_socket(addr: SocketAddr) -> Result<UdpSocket, IoError>;
    
    // HTTP客户端（平台优化）
    async fn http_get(url: &str) -> Result<HttpResponse, HttpError> {
        #[cfg(not(wasm))]
        {
            reqwest::get(url).await
        }
        
        #[cfg(wasm)]
        {
            web_sys::fetch(url).await
        }
    }
}

// 平台特定的网络优化
impl NetworkStack for NativeNetwork {
    #[cfg(target_os = "linux")]
    async fn tcp_connect(addr: SocketAddr) -> Result<TcpStream, IoError> {
        // Linux特定优化：使用epoll
        linux_tcp::connect_with_epoll(addr).await
    }
    
    #[cfg(target_os = "windows")]
    async fn tcp_connect(addr: SocketAddr) -> Result<TcpStream, IoError> {
        // Windows特定优化：使用IOCP
        windows_tcp::connect_with_iocp(addr).await
    }
}
```

### WebSocket跨平台支持：
```aether
// 统一的WebSocket客户端
struct WebSocketClient {
    #[cfg(not(wasm))]
    native_client: NativeWebSocket,
    
    #[cfg(wasm)]
    browser_client: BrowserWebSocket,
}

impl WebSocketClient {
    async fn connect(url: &str) -> Result<Self, WsError> {
        Ok(WebSocketClient {
            #[cfg(not(wasm))]
            native_client: NativeWebSocket::connect(url).await?,
            
            #[cfg(wasm)]
            browser_client: BrowserWebSocket::new(url)?,
        })
    }
    
    async fn send(&self, message: &[u8]) -> Result<(), WsError> {
        #[cfg(not(wasm))]
        self.native_client.send(message).await
        
        #[cfg(wasm)]
        self.browser_client.send(message).await
    }
    
    async fn receive(&self) -> Result<Vec<u8>, WsError> {
        #[cfg(not(wasm))]
        self.native_client.receive().await
        
        #[cfg(wasm)]
        self.browser_client.receive().await
    }
}
```

## 图形用户界面跨平台

### 声明式UI框架：
```aether
// 平台无关的UI描述
#[derive(Component)]
struct Button {
    text: String,
    on_click: Callback<()>,
    style: ButtonStyle,
}

impl Button {
    fn view(&self) -> View {
        View::button()
            .text(&self.text)
            .on_click(self.on_click.clone())
            .style(self.style)
    }
}

// 平台特定的渲染
trait Renderer {
    fn render_button(button: &Button) -> PlatformWidget;
}

// 各平台实现
#[cfg(target_os = "windows")]
impl Renderer for Win32Renderer {
    fn render_button(button: &Button) -> HWND {
        // Windows按钮控件
        create_windows_button(&button.text, button.on_click)
    }
}

#[cfg(target_os = "macos")]
impl Renderer for CocoaRenderer {
    fn render_button(button: &Button) -> NSButton {
        // macOS按钮控件
        create_ns_button(&button.text, button.on_click)
    }
}

#[cfg(wasm)]
impl Renderer for WebRenderer {
    fn render_button(button: &Button) -> Element {
        // HTML按钮元素
        create_html_button(&button.text, button.on_click)
    }
}
```

### 响应式布局系统：
```aether
// 跨平台布局引擎
struct LayoutEngine {
    constraints: LayoutConstraints,
    platform_adapter: PlatformAdapter,
}

impl LayoutEngine {
    fn calculate_layout(&self, view: &View) -> LayoutRect {
        let mut rect = self.constraints.initial_rect();
        
        // 平台特定的布局调整
        rect = self.platform_adapter.adjust_for_platform(rect);
        
        // 递归计算子视图布局
        for child in view.children() {
            let child_rect = self.calculate_layout(child);
            rect = rect.union(child_rect);
        }
        
        rect
    }
}

// 平台适配器
trait PlatformAdapter {
    fn adjust_for_platform(&self, rect: LayoutRect) -> LayoutRect;
}

#[cfg(target_os = "windows")]
impl PlatformAdapter for WindowsAdapter {
    fn adjust_for_platform(&self, rect: LayoutRect) -> LayoutRect {
        // Windows DPI缩放调整
        rect.scale(self.get_dpi_scale())
    }
}

#[cfg(target_os = "macos")]
impl PlatformAdapter for MacOSAdapter {
    fn adjust_for_platform(&self, rect: LayoutRect) -> LayoutRect {
        // macOS Retina显示支持
        rect.scale(self.get_retina_scale())
    }
}
```

## 移动平台支持

### iOS集成：
```aether
// iOS特定功能
#[cfg(target_os = "ios")]
mod ios {
    use objc::runtime::Object;
    
    pub struct IOSApp {
        app_delegate: *mut Object,
    }
    
    impl IOSApp {
        pub fn new() -> Self {
            unsafe {
                let delegate = msg_send![class!(UIApplicationDelegate), new];
                IOSApp { app_delegate: delegate }
            }
        }
        
        pub fn run(&self) {
            unsafe {
                let _: () = msg_send![class!(UIApplicationMain), 
                    argc, argv, nil, self.app_delegate];
            }
        }
    }
    
    // iOS触摸事件处理
    pub fn handle_touch_event(event: TouchEvent) -> bool {
        match event.phase {
            TouchPhase::Began => { /* 触摸开始 */ }
            TouchPhase::Moved => { /* 触摸移动 */ }
            TouchPhase::Ended => { /* 触摸结束 */ }
        }
        true
    }
}
```

### Android集成：
```aether
// Android特定功能
#[cfg(target_os = "android")]
mod android {
    use jni::JNIEnv;
    
    pub struct AndroidApp {
        vm: JavaVM,
        activity: jobject,
    }
    
    impl AndroidApp {
        pub fn from_jni(env: &JNIEnv, activity: jobject) -> Self {
            AndroidApp {
                vm: env.get_java_vm().unwrap(),
                activity,
            }
        }
        
        pub fn run_on_ui_thread<F: FnOnce() + Send + 'static>(&self, f: F) {
            // 在Android UI线程执行代码
            let env = self.vm.attach_current_thread().unwrap();
            env.call_method(self.activity, "runOnUiThread", 
                "(Ljava/lang/Runnable;)V", &[f.into()]).unwrap();
        }
    }
    
    // Android生命周期管理
    pub fn on_create(bundle: Option<&Bundle>) {
        // 应用创建
    }
    
    pub fn on_resume() {
        // 应用恢复
    }
    
    pub fn on_pause() {
        // 应用暂停
    }
}
```

## WebAssembly支持

### 浏览器API绑定：
```aether
// WebAssembly模块定义
#[wasm_bindgen]
pub struct WebApp {
    canvas: web_sys::HtmlCanvasElement,
    context: web_sys::CanvasRenderingContext2d,
}

#[wasm_bindgen]
impl WebApp {
    pub fn new(canvas_id: &str) -> Result<WebApp, JsValue> {
        let window = web_sys::window().unwrap();
        let document = window.document().unwrap();
        let canvas = document.get_element_by_id(canvas_id).unwrap();
        let canvas: web_sys::HtmlCanvasElement = canvas.dyn_into()?;
        
        let context = canvas
            .get_context("2d")?
            .unwrap()
            .dyn_into::<web_sys::CanvasRenderingContext2d>()?;
            
        Ok(WebApp { canvas, context })
    }
    
    pub fn draw(&self, x: f64, y: f64, radius: f64) {
        self.context.begin_path();
        self.context
            .arc(x, y, radius, 0.0, std::f64::consts::PI * 2.0)
            .unwrap();
        self.context.stroke();
    }
    
    // 处理浏览器事件
    pub fn on_click(&self, event: web_sys::MouseEvent) {
        let x = event.client_x() as f64;
        let y = event.client_y() as f64;
        self.draw(x, y, 10.0);
    }
}
```

### Web Workers多线程：
```aether
// WebAssembly多线程支持
#[wasm_bindgen]
pub struct WebWorker {
    worker: web_sys::Worker,
}

#[wasm_bindgen]
impl WebWorker {
    pub fn new(script_url: &str) -> Result<WebWorker, JsValue> {
        let worker = web_sys::Worker::new(script_url)?;
        Ok(WebWorker { worker })
    }
    
    pub fn post_message(&self, data: &JsValue) -> Result<(), JsValue> {
        self.worker.post_message(data)?;
        Ok(())
    }
    
    pub fn set_onmessage(&self, callback: &js_sys::Function) {
        self.worker.set_onmessage(Some(callback));
    }
}

// 在Worker中运行的计算密集型任务
#[wasm_bindgen]
pub fn heavy_computation(input: &[f64]) -> Vec<f64> {
    input.iter().map(|x| x * x).collect()
}
```

## 嵌入式系统支持

### 无标准库环境：
```aether
// 嵌入式目标配置
#![no_std]  // 禁用标准库
#![no_main] // 禁用主函数

// 嵌入式入口点
#[entry]
fn main() -> ! {
    // 初始化硬件
    init_peripherals();
    
    // 主循环
    loop {
        process_sensors();
        update_actuators();
        delay(1000); // 1秒延迟
    }
}

// 硬件抽象层
trait Hardware {
    type Error;
    
    fn read_sensor(&mut self) -> Result<u16, Self::Error>;
    fn write_actuator(&mut self, value: u8) -> Result<(), Self::Error>;
    fn delay_ms(&mut self, ms: u32);
}

// ARM Cortex-M特定实现
#[cfg(target_arch = "arm")]
impl Hardware for CortexMHardware {
    type Error = CortexMError;
    
    fn read_sensor(&mut self) -> Result<u16, Self::Error> {
        // 读取ADC值
        Ok(unsafe { read_volatile(ADC_REGISTER) })
    }
    
    fn delay_ms(&mut self, ms: u32) {
        // 使用SysTick定时器延迟
        systick_delay(ms);
    }
}
```

### 内存受限环境优化：
```aether
// 嵌入式内存管理
struct EmbeddedAllocator {
    heap: &'static mut [u8],
    next: usize,
}

impl EmbeddedAllocator {
    const HEAP_SIZE: usize = 16 * 1024; // 16KB堆
    
    fn new() -> Self {
        static mut HEAP: [u8; Self::HEAP_SIZE] = [0; Self::HEAP_SIZE];
        EmbeddedAllocator {
            heap: unsafe { &mut HEAP },
            next: 0,
        }
    }
}

// 零分配数据结构
struct SensorData {
    values: [f32; 100],  // 栈上数组，不分配堆内存
    index: usize,
}

impl SensorData {
    fn push(&mut self, value: f32) {
        self.values[self.index] = value;
        self.index = (self.index + 1) % self.values.len();
    }
    
    fn average(&self) -> f32 {
        self.values.iter().sum::<f32>() / self.values.len() as f32
    }
}
```

## 交叉编译工具链

### 多目标构建配置：
```aether
// aether.toml中的交叉编译配置
[package]
name = "my-app"
version = "0.1.0"

# 构建目标配置
[target.x86_64-pc-windows-msvc]
linker = "x86_64-w64-mingw32-gcc"
ar = "x86_64-w64-mingw32-ar"

[target.aarch64-apple-ios]
sdk = "iphoneos"
minimum_ios_version = "12.0"

[target.wasm32-unknown-unknown]
linker = "wasm-ld"
ar = "llvm-ar"

# 特性标志
[features]
default = ["desktop"]
desktop = ["gui", "file-dialog"]
mobile = ["touch", "accelerometer"]
web = ["wasm-bindgen", "web-sys"]
embedded = ["no-std", "cortex-m"]

# 构建脚本
[build]
target = "x86_64-pc-windows-msvc"  # 默认目标
cross_compile = true
```

### 自动化交叉编译：
```aether
// 构建脚本：build.aether
task!("build-all", || {
    let targets = [
        "x86_64-pc-windows-msvc",
        "x86_64-unknown-linux-gnu", 
        "aarch64-apple-darwin",
        "wasm32-unknown-unknown",
        "thumbv7em-none-eabi",  // 嵌入式ARM
    ];
    
    for target in targets {
        println!("构建目标: {}", target);
        aether_build::build_target(target)?;
    }
    
    Ok(())
});

task!("build-release", || {
    // 为每个平台构建发布版本
    aether_build::build_with_profile("release", |config| {
        config
            .target("x86_64-pc-windows-msvc")
            .feature("desktop")
            .optimize_level(3);
            
        config
            .target("wasm32-unknown-unknown")  
            .feature("web")
            .optimize_level("z");  // 大小优化
    })
});
```

## 平台检测与特性查询

### 运行时平台检测：
```aether
// 平台信息查询
struct PlatformInfo {
    os: OperatingSystem,
    arch: Architecture,
    features: PlatformFeatures,
}

impl PlatformInfo {
    fn current() -> Self {
        PlatformInfo {
            os: detect_os(),
            arch: detect_arch(),
            features: detect_features(),
        }
    }
    
    fn supports_feature(&self, feature: PlatformFeature) -> bool {
        self.features.contains(feature)
    }
}

// 使用示例
fn optimize_for_platform() {
    let platform = PlatformInfo::current();
    
    if platform.supports_feature(PlatformFeature::SIMD) {
        use_simd_optimizations();
    }
    
    if platform.supports_feature(PlatformFeature::GPU) {
        use_gpu_acceleration();
    }
    
    match platform.os {
        OperatingSystem::Linux => apply_linux_optimizations(),
        OperatingSystem::Windows => apply_windows_optimizations(),
        OperatingSystem::macOS => apply_macos_optimizations(),
        _ => use_generic_implementation(),
    }
}
```

### 条件特性启用：
```aether
// 基于平台自动启用特性
fn auto_configure() -> BuildConfig {
    let mut config = BuildConfig::new();
    
    // 根据目标平台启用适当特性
    if cfg!(target_os = "windows") {
        config.enable_feature("win32-api");
    }
    
    if cfg!(target_os = "linux") {
        config.enable_feature("posix-api");
    }
    
    if cfg!(target_arch = "x86_64") {
        config.enable_feature("avx2");
    }
    
    if cfg!(target_arch = "aarch64") {
        config.enable_feature("neon");
    }
    
    // 检测并启用可选特性
    if has_feature("cuda") {
        config.enable_feature("gpu-compute");
    }
    
    config
}
```

## 测试与验证

### 跨平台测试框架：
```aether
// 多平台测试运行器
struct CrossPlatformTestRunner {
    targets: Vec<TestTarget>,
}

impl CrossPlatformTestRunner {
    async fn run_tests(&self) -> TestResults {
        let mut results = TestResults::new();
        
        for target in &self.targets {
            println!("在 {} 上运行测试...", target.name);
            
            let target_results = self.run_on_target(target).await;
            results.merge(target_results);
        }
        
        results
    }
    
    async fn run_on_target(&self, target: &TestTarget) -> TestResults {
        // 为特定目标编译测试
        let test_binary = self.compile_for_target(target).await?;
        
        // 在目标环境执行测试
        if target.is_remote {
            self.run_remote_test(test_binary, target).await
        } else {
            self.run_local_test(test_binary).await
        }
    }
}

// 平台特定的测试用例
#[cfg(test)]
mod tests {
    #[test]
    #[cfg(target_os = "windows")]
    fn test_windows_specific() {
        // 只在Windows上运行的测试
        test_win32_api();
    }
    
    #[test] 
    #[cfg(target_os = "linux")]
    fn test_linux_specific() {
        // 只在Linux上运行的测试
        test_posix_api();
    }
}
```

## 部署与分发

### 多平台包分发：
```aether
// 包分发配置
struct PackageDistributor {
    platforms: Vec<DistributionPlatform>,
}

impl PackageDistributor {
    async fn distribute(&self, package: &Package) -> Result<(), DistributeError> {
        for platform in &self.platforms {
            match platform {
                DistributionPlatform::CratesIo => {
                    self.publish_to_crates_io(package).await?;
                }
                DistributionPlatform::Npm => {
                    self.publish_to_npm(package).await?;
                }
                DistributionPlatform::DockerHub => {
                    self.publish_to_docker(package).await?;
                }
                DistributionPlatform::AppStore => {
                    self.publish_to_app_store(package).await?;
                }
            }
        }
        
        Ok(())
    }
}

// 平台特定的包格式
enum PackageFormat {
    #[cfg(target_os = "windows")]
    Msi,        // Windows安装包
    
    #[cfg(target_os = "macos")]
    Dmg,        // macOS磁盘映像
    
    #[cfg(target_os = "linux")]
    Deb,        // Debian包
    Rpm,        // RedHat包
    
    #[cfg(wasm)]
    Wasm,       // WebAssembly模块
    
    Universal,  // 通用格式（如tar.gz）
}
```

## 跨平台支持总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 条件编译 | 编译时平台检测 | 零运行时开销，精确优化 |
| 统一API | 平台抽象层 | 代码复用，维护简单 |
| WebAssembly | 完整浏览器支持 | 现代Web应用开发 |
| 移动平台 | iOS/Android原生集成 | 真正的原生体验 |
| 嵌入式系统 | 无标准库支持 | 资源受限环境运行 |
| 交叉编译 | 多目标构建系统 | 一次构建，多平台分发 |

**核心创新**：通过编译时智能调度和运行时特性检测，在保持代码简洁的同时，实现真正的跨平台兼容性。

---

## 互动挑战：跨平台设计练习

```aether
// 挑战1：设计一个跨平台的文件监视器
// 要求：在Windows、Linux、macOS上监控文件变化，API统一
// 你的设计：

// 挑战2：实现一个跨平台的系统托盘应用
// 要求：在桌面和移动端提供一致的用户体验
// 你的设计：

// 挑战3：优化以下存在跨平台问题的代码
fn problematic_cross_platform_code() {
    // 问题1：硬编码路径分隔符
    let path = "C:\\Users\\Alice\\file.txt";  // 只在Windows工作
    
    // 问题2：平台特定的API调用
    #[cfg(not(target_os = "windows"))]
    unix_specific_function();  // 非Windows平台缺少实现
    
    // 问题3：假设特定字节序
    let value = u32::from_le_bytes(bytes);  // 假设小端序
}
```

**思考**：如何用AetherLang的跨平台特性改进这些代码？

---

**下一章预告**：  
跨平台支持设计完成后，我们将探索AetherLang的性能优化系统。在[第7章]中，我们将介绍编译时优化、运行时性能分析和高级性能调优技术。

> "好的跨平台设计应该像好的国际标准——在不同环境中都能工作，同时尊重本地习惯和优势。"  
> —— AetherLang跨平台设计哲学