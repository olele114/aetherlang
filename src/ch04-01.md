# 4.1 宏系统：编译时的代码生成与转换
**——让编译器为你写代码**

> "宏是编程中的魔法——但好的宏就像好的魔法，有明确的规则和可预测的结果。"  
> —— 某位在元编程中寻找优雅之道的开发者

宏系统是AetherLang元编程的核心。它允许在编译时生成和转换代码，从而减少样板代码，提高表达力。我们的宏系统设计强调可读性、安全性和强大的功能。

## 宏系统设计哲学

### 设计原则：
1. **卫生性**：宏不会意外捕获或破坏外部变量
2. **类型安全**：宏生成的代码参与类型检查
3. **调试友好**：宏错误信息清晰，支持逐步展开
4. **渐进复杂**：从简单宏到复杂宏的平滑学习曲线

## 声明宏：基础代码生成

### 基础宏：减少样板代码
```aether
// 定义一个简单的宏：vec!
macro_rules! vec {
    // 空向量
    () => {
        Vec::new()
    };
    
    // 带初始值的向量
    ($($element:expr),* $(,)?) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($element);
            )*
            temp_vec
        }
    };
}

// 使用宏
val empty = vec![];           // 生成：Vec::new()
val numbers = vec![1, 2, 3];  // 生成带初始值的向量
```

### 模式匹配宏：处理多种情况
```aether
// 匹配不同模式的宏
macro_rules! calculate {
    // 加法
    (add $a:expr, $b:expr) => {
        $a + $b
    };
    
    // 乘法
    (multiply $a:expr, $b:expr) => {
        $a * $b
    };
    
    // 默认情况
    ($a:expr) => {
        $a
    };
}

// 使用示例
val sum = calculate!(add 5, 3);      // 8
val product = calculate!(multiply 5, 3); // 15
val single = calculate!(42);         // 42
```

## 过程宏：更强大的代码生成

### 派生宏：自动实现特质
```aether
// 定义派生宏
#[derive(Debug, Clone, Serialize)]
struct User {
    name: String,
    age: u32,
    email: String,
}

// 宏展开后相当于：
impl Debug for User {
    fn fmt(&self, f: &mut Formatter) -> Result {
        // 自动生成的Debug实现
        f.debug_struct("User")
            .field("name", &self.name)
            .field("age", &self.age)
            .field("email", &self.email)
            .finish()
    }
}

impl Clone for User {
    fn clone(&self) -> Self {
        User {
            name: self.name.clone(),
            age: self.age,
            email: self.email.clone(),
        }
    }
}

// 以及Serialize的实现...
```

### 属性宏：自定义属性
```aether
// 自定义属性宏
#[route("/api/users/:id", method = "GET")]
fn get_user(id: u64) -> Result<User, Error> {
    // 处理逻辑
}

// 属性宏可以生成额外的代码
// 比如注册路由、生成OpenAPI文档等
```

### 函数式宏：灵活的代码转换
```aether
// 函数式过程宏
#[function_macro]
fn sql(query: TokenStream) -> TokenStream {
    // 解析SQL查询，生成安全的数据库查询代码
    let sql_str = parse_sql(query);
    generate_safe_query(sql_str)
}

// 使用示例
val users = sql!("SELECT * FROM users WHERE age > 18");
// 宏展开为：
// let users = {
//     let query = prepare_statement("SELECT * FROM users WHERE age > ?");
//     query.bind(18).execute()
// };
```

## 卫生宏与变量捕获

### 卫生性保证：
```aether
// 卫生宏不会意外捕获外部变量
macro_rules! hygienic_example {
    ($value:expr) => {
        {
            let temp = $value * 2;  // temp是宏内部的局部变量
            temp + 1
        }
    };
}

fn test_hygiene() {
    let temp = 100;  // 外部变量
    let result = hygienic_example!(5);
    println!("结果: {}, 外部temp: {}", result, temp); 
    // 输出：结果: 11, 外部temp: 100
    // 宏内部的temp不会影响外部变量
}
```

### 显式变量捕获：
```aether
// 需要捕获外部变量时使用显式语法
macro_rules! capture_example {
    ($body:expr) => {
        |x| {
            let result = $body;  // 可以捕获外部变量
            result + x
        }
    };
}

fn test_capture() {
    let multiplier = 2;
    let closure = capture_example!(multiplier * 10);
    println!("结果: {}", closure(5));  // 2*10 + 5 = 25
}
```

## 宏的调试与错误处理

### 编译时宏展开检查：
```aether
// 查看宏展开结果
#[debug_macro_expansion]
fn test_macro_expansion() {
    let v = vec![1, 2, 3];
    // 编译时会输出宏展开的代码
}

/*
宏展开输出：
fn test_macro_expansion() {
    let v = {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    };
}
*/
```

### 友好的宏错误信息：
```aether
// 当宏使用不当时
val invalid = vec![1, "hello", 3];  // 类型不匹配

/*
错误：宏展开类型错误
  --> src/main.aether:15:25
   |
15 | val invalid = vec![1, "hello", 3];
   |                         ^^^^^^ 期望一致的类型，找到 `&str`，但之前是 `i32`
   |
帮助：vec!宏要求所有元素类型相同
      考虑使用异构集合：
      let heterogeneous = (1, "hello", 3);  // 元组
      或者使用枚举：
      enum Mixed { Int(i32), Str(String) }
*/
```

## 高级宏技巧

### 递归宏：处理嵌套结构
```aether
// 递归宏处理嵌套表达式
macro_rules! calculate_expression {
    // 基础情况：单个数字
    ($x:literal) => { $x };
    
    // 递归情况：加法
    ($a:expr + $b:expr) => {
        calculate_expression!($a) + calculate_expression!($b)
    };
    
    // 递归情况：乘法
    ($a:expr * $b:expr) => {
        calculate_expression!($a) * calculate_expression!($b)
    };
}

// 使用示例
val result = calculate_expression!(2 + 3 * 4);  // 14
// 展开为：2 + (3 * 4)
```

### 重复模式处理：
```aether
// 处理可变数量参数
macro_rules! hash_map {
    ($($key:expr => $value:expr),* $(,)?) => {
        {
            let mut map = HashMap::new();
            $(
                map.insert($key, $value);
            )*
            map
        }
    };
}

// 使用示例
val capitals = hash_map!{
    "France" => "Paris",
    "Japan" => "Tokyo",
    "USA" => "Washington D.C."
};
```

## 领域特定语言（DSL）

### 内部DSL：使用宏创建
```aether
// 创建HTML DSL
macro_rules! html {
    (<$tag:ident>$($content:tt)*</$tag:ident>) => {
        Element::new(stringify!($tag))
            .with_children(html!($($content)*))
    };
    
    (<$tag:ident $($attr:ident=$value:expr)* />) => {
        Element::new(stringify!($tag))
            $(.with_attribute(stringify!($attr), $value))*
    };
    
    ($text:expr) => {
        Element::text($text)
    };
    
    () => { Vec::new() };
}

// 使用HTML DSL
val page = html!(
    <html>
        <head>
            <title>"我的网页"</title>
        </head>
        <body>
            <h1 class="title">"欢迎"</h1>
            <p>"这是一个段落"</p>
        </body>
    </html>
);
```

### 测试DSL：
```aether
// 测试断言DSL
macro_rules! assert_that {
    ($value:expr) => {
        Assertion::new($value)
    };
}

macro_rules! is_equal_to {
    ($expected:expr) => {
        |actual| actual == $expected
    };
}

macro_rules! is_greater_than {
    ($threshold:expr) => {
        |actual| actual > $threshold
    };
}

// 使用测试DSL
fn test_example() {
    assert_that!(calculate(2, 3)).is_equal_to(5);
    assert_that!(get_score()).is_greater_than(60);
}
```

## 编译时计算与常量求值

### 常量函数：编译时计算
```aether
// 常量函数在编译时求值
const fn factorial(n: u32) -> u32 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}

// 编译时计算
const FACTORIAL_10: u32 = factorial(10);  // 3628800

// 使用编译时常量
val array = [0u8; FACTORIAL_10 as usize];  // 数组大小在编译时确定
```

### 编译时反射：
```aether
// 编译时类型信息
const fn type_name<T>() -> &'static str {
    std::any::type_name::<T>()
}

// 编译时使用
const INT_NAME: &str = type_name::<i32>();  // "i32"

// 结构体信息反射
#[derive(Reflect)]
struct User {
    name: String,
    age: u32,
}

// 编译时获取字段信息
const USER_FIELDS: &[FieldInfo] = User::fields();
// [{name: "name", type: "String"}, {name: "age", type: "u32"}]
```

## 宏的最佳实践

### 宏设计原则：
```aether
// 好宏：清晰、专注、可组合
macro_rules! good_macro {
    // 每个模式都有明确的目的
    ($x:expr) => { ... };
    ($x:expr, $y:expr) => { ... };
}

// 不好：过于复杂，难以理解
macro_rules! bad_macro {
    // 太多模式，逻辑混乱
    ($($t:tt)*) => { ... };
}
```

### 文档与测试：
```aether
/// 创建一个向量宏
/// 
/// # 示例
/// ```
/// let v = vec![1, 2, 3];
/// assert_eq!(v, [1, 2, 3]);
/// ```
macro_rules! vec {
    // ... 实现
}

// 宏的单元测试
#[test]
fn test_vec_macro() {
    let v = vec![1, 2, 3];
    assert_eq!(v.len(), 3);
    assert_eq!(v[0], 1);
}
```

## 宏系统的限制与边界

### 编译时性能考虑：
```aether
// 避免过度复杂的宏展开
macro_rules! simple_and_efficient {
    // 简单的模式匹配
    ($x:expr) => { ... };
}

// 避免深层递归宏
macro_rules! deeply_nested {
    // 可能导致编译时间过长
    // ... 复杂的递归模式
}
```

### 错误传播：
```aether
// 宏中的错误处理
macro_rules! try_or_default {
    ($expr:expr, $default:expr) => {
        match $expr {
            Ok(val) => val,
            Err(_) => $default,
        }
    };
}

// 使用示例
val data = try_or_default!(parse_input("invalid"), Default::default());
```

## 实际应用案例

### 序列化/反序列化宏：
```aether
// 自动派生序列化
#[derive(Serialize, Deserialize)]
struct Config {
    host: String,
    port: u16,
    timeout: Duration,
}

// 宏生成的代码处理所有细节
val config = Config {
    host: "localhost".to_string(),
    port: 8080,
    timeout: Duration::from_secs(30),
};

let json = config.to_json();  // 自动生成的序列化方法
let config2 = Config::from_json(&json);  // 自动生成的反序列化
```

### Web框架路由宏：
```aether
// 路由宏简化Web开发
#[get("/users/<id>")]
fn get_user(id: u64) -> Result<Json<User>, Error> {
    let user = database::find_user(id)?;
    Ok(Json(user))
}

#[post("/users", data = "<user>")]
fn create_user(user: Json<NewUser>) -> Result<Json<UserId>, Error> {
    let user_id = database::insert_user(user.0)?;
    Ok(Json(user_id))
}

// 宏自动注册路由并生成OpenAPI文档
```

## 宏系统总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 声明宏 | 模式匹配代码生成 | 简单易用，减少样板代码 |
| 过程宏 | 语法树转换 | 强大灵活，支持复杂转换 |
| 卫生性 | 自动变量重命名 | 避免意外捕获，提高可靠性 |
| 编译时计算 | 常量求值 | 零运行时开销，性能优化 |
| DSL支持 | 自定义语法 | 领域特定抽象，提高表达力 |

**核心创新**：在保持宏系统强大功能的同时，通过更好的错误信息和调试工具，使元编程更加可访问。

---

## 互动挑战：宏设计练习

```aether
// 挑战1：设计一个日志宏
// 要求：支持不同日志级别，自动包含文件名和行号，编译时过滤
// 你的设计：

// 挑战2：实现一个测试框架宏
// 要求：支持测试夹具、参数化测试、异步测试
// 你的设计：

// 挑战3：优化以下宏设计
macro_rules! poorly_designed {
    ($a:expr) => { ... };
    ($a:expr, $b:expr) => { ... };
    ($a:expr, $b:expr, $c:expr) => { ... };
    // 重复模式，如何改进？
}
```

**思考**：如何用AetherLang的宏系统改进这些设计？

---

**下一节预告**：  
宏系统设计完成后，我们将探索更高级的元编程特性。在[4.2]中，我们将介绍编译时反射和代码生成，让编译器成为更强大的编程助手。

> "好的宏设计应该像好的工具箱——每个工具都有明确的用途，组合起来能构建复杂系统，但不会让使用者感到困惑。"  
> —— AetherLang宏设计哲学