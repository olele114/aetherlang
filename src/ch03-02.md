# 3.2 泛型系统：代码复用与类型安全的完美结合
**——让同一份代码为不同类型工作，而不损失性能**

> "泛型是编程中的'一次编写，到处运行'——但这次是真的，不骗你。"  
> —— 某位在模板元编程中顿悟的C++程序员

泛型是现代编程语言的核心特性。AetherLang的泛型系统既要提供强大的抽象能力，又要保持零运行时开销。我们的目标是：**让泛型代码既安全又高效，同时保持可读性**。

## 泛型设计哲学

### 设计原则：
1. **零成本抽象**：泛型代码与手写特化代码性能相同
2. **类型安全**：编译时捕获所有类型错误
3. **表达力强**：支持复杂类型约束和高级模式
4. **错误友好**：泛型错误信息要像导师一样指导修复

## 基础泛型语法

### 泛型函数：一次定义，多种类型使用
```aether
// 最简单的泛型函数
fn identity<T>(value: T) -> T {
    value  // 返回相同类型的值
}

// 使用示例
val number = identity(42);      // T 推导为 i32
val text = identity("hello");   // T 推导为 &str
val point = identity(Point { x: 1, y: 2 });  // T 推导为 Point
```

### 泛型结构体：可重用的数据结构
```aether
// 泛型容器
struct Box<T> {
    value: T,
}

// 使用示例
val number_box = Box { value: 42 };
val string_box = Box { value: "hello".to_string() };

// 多层泛型
struct Pair<T, U> {
    first: T,
    second: U,
}

val mixed_pair = Pair { first: 42, second: "answer" };
```

### 泛型枚举：类型安全的联合
```aether
// 可选值枚举
enum Option<T> {
    Some(T),
    None,
}

// 结果枚举
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// 使用示例
val maybe_number: Option<i32> = Option::Some(42);
val maybe_string: Option<String> = Option::None;

val result: Result<String, IoError> = Result::Ok("成功".to_string());
```

## 特质约束：为泛型添加行为要求

### 基础特质约束：
```aether
// 定义特质
trait Printable {
    fn print(&self);
}

// 泛型函数带约束
fn print_all<T: Printable>(items: &[T]) {
    for item in items {
        item.print();
    }
}

// 为内置类型实现特质
impl Printable for i32 {
    fn print(&self) {
        println!("数字: {}", self);
    }
}

impl Printable for String {
    fn print(&self) {
        println!("字符串: {}", self);
    }
}
```

### 多重约束与where子句：
```aether
// 复杂的多重约束
fn complex_function<T>(value: T) -> T 
where 
    T: Clone + Display + PartialOrd,  // 必须可克隆、可显示、可比较
{
    println!("值: {}", value);
    value.clone()
}

// 更清晰的where语法
fn advanced_processing<T, U>(input: T) -> Result<U, ProcessingError>
where
    T: Serialize + DeserializeOwned,
    U: From<T> + Default,
{
    // 复杂的处理逻辑
}
```

### 关联类型：特质中的类型家族
```aether
// 带有关联类型的特质
trait Iterator {
    type Item;  // 关联类型
    
    fn next(&mut self) -> Option<Self::Item>;
}

// 实现带关联类型的特质
struct Range {
    current: i32,
    end: i32,
}

impl Iterator for Range {
    type Item = i32;  // 指定关联类型
    
    fn next(&mut self) -> Option<i32> {
        if self.current < self.end {
            let result = self.current;
            self.current += 1;
            Some(result)
        } else {
            None
        }
    }
}
```

## 泛型特化：性能优化利器

### 条件特化：为特定类型优化
```aether
// 通用实现
trait FastHash {
    fn fast_hash(&self) -> u64;
}

// 为整数类型特化
impl FastHash for i32 {
    fn fast_hash(&self) -> u64 {
        *self as u64  // 直接转换，快速
    }
}

// 为字符串类型特化
impl FastHash for String {
    fn fast_hash(&self) -> u64 {
        // 使用更复杂的哈希算法
        sophisticated_hash(self.as_bytes())
    }
}

// 泛型函数自动选择特化版本
fn compute_hash<T: FastHash>(value: &T) -> u64 {
    value.fast_hash()  // 根据T的类型调用不同实现
}
```

### 默认实现：减少样板代码
```aether
trait Serialize {
    fn to_json(&self) -> String;
    
    // 默认实现
    fn to_pretty_json(&self) -> String {
        let json = self.to_json();
        format_json_pretty(&json)  // 基于基础方法实现
    }
}

// 类型只需要实现核心方法
impl Serialize for User {
    fn to_json(&self) -> String {
        format!(r#"{{"name":"{}","age":{}}}"#, self.name, self.age)
    }
    // to_pretty_json 自动获得默认实现
}
```

## 高级泛型模式

### 泛型递归：类型安全的递归数据结构
```aether
// 递归枚举（如链表）
enum List<T> {
    Cons(T, Box<List<T>>),  // 递归包含自身
    Nil,
}

// 使用示例
val list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));

// 泛型树结构
enum Tree<T> {
    Leaf(T),
    Node(Vec<Tree<T>>),
}
```

### 泛型闭包：高阶函数
```aether
// 接受闭包参数的泛型函数
fn map<T, U, F>(items: &[T], transform: F) -> Vec<U>
where
    F: Fn(&T) -> U,  // F必须是闭包特质
{
    items.iter().map(transform).collect()
}

// 使用示例
val numbers = [1, 2, 3, 4];
let doubled = map(&numbers, |x| x * 2);      // [2, 4, 6, 8]
let strings = map(&numbers, |x| x.to_string()); // ["1", "2", "3", "4"]
```

### 泛型常量：编译时计算
```aether
// 常量泛型参数（编译时已知的值）
struct Array<T, const N: usize> {
    data: [T; N],  // 编译时固定大小
}

// 使用示例
val arr: Array<i32, 5> = Array { data: [1, 2, 3, 4, 5] };
val matrix: Array<Array<f64, 3>, 3> = Array { 
    data: [
        Array { data: [1.0, 0.0, 0.0] },
        Array { data: [0.0, 1.0, 0.0] },
        Array { data: [0.0, 0.0, 1.0] },
    ]
};
```

## 泛型与生命周期

### 生命周期参数：引用安全
```aether
// 带生命周期的泛型函数
fn longest<'a, T>(x: &'a T, y: &'a T) -> &'a T 
where 
    T: PartialOrd,  // 可比较的类型
{
    if x > y { x } else { y }
}

// 生命周期省略规则（编译器自动推断）
fn first_word(s: &str) -> &str {
    s.split_whitespace().next().unwrap_or("")
}
```

### 高阶生命周期：复杂引用模式
```aether
// 处理闭包中的生命周期
fn process_with_callback<'a, F, T>(data: &'a [T], callback: F) -> Vec<&'a T>
where
    F: Fn(&T) -> bool + 'a,  // 闭包生命周期与数据相同
{
    data.iter().filter(|item| callback(item)).collect()
}
```

## 泛型错误处理

### 错误类型泛型化：
```aether
// 泛型错误处理
trait Fallible<T, E> {
    fn try_operation(&self) -> Result<T, E>;
}

// 为不同错误类型实现
impl Fallible<String, ParseError> for &str {
    fn try_operation(&self) -> Result<String, ParseError> {
        self.parse().map_err(|_| ParseError::InvalidFormat)
    }
}

impl Fallible<i32, MathError> for f64 {
    fn try_operation(&self) -> Result<i32, MathError> {
        if self.is_nan() {
            Err(MathError::NotANumber)
        } else {
            Ok(self.round() as i32)
        }
    }
}
```

### 错误转换泛型：
```aether
// 泛型错误转换
fn convert_error<T, E1, E2>(result: Result<T, E1>) -> Result<T, E2>
where
    E1: Into<E2>,  // E1可以转换为E2
{
    result.map_err(|e| e.into())
}
```

## 泛型性能优化

### 单态化：零成本抽象的实现
```aether
// 源代码：泛型函数
fn add<T: Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// 编译后：为每种使用类型生成特化版本
fn add_i32(a: i32, b: i32) -> i32 { a + b }
fn add_f64(a: f64, b: f64) -> f64 { a + b }
fn add_string(a: String, b: String) -> String { a + &b }

// 使用处直接调用特化版本
val x = add(1, 2);        // 调用add_i32
val y = add(1.0, 2.0);    // 调用add_f64
```

### 内联优化：小函数自动展开
```aether
// 标记为内联的泛型函数
#[inline(always)]
fn small_helper<T: Copy>(value: T) -> T {
    // 小函数，适合内联
    value
}

// 使用处可能直接展开
val result = small_helper(42);
// 可能编译为：val result = 42; （直接替换）
```

## 泛型代码的组织与可见性

### 泛型模块：相关功能分组
```aether
// 泛型工具模块
mod collection_utils {
    pub trait Collection<T> {
        fn len(&self) -> usize;
        fn is_empty(&self) -> bool;
    }
    
    // 为标准集合实现
    impl<T> Collection<T> for Vec<T> {
        fn len(&self) -> usize { self.len() }
        fn is_empty(&self) -> bool { self.is_empty() }
    }
    
    impl<T> Collection<T> for &[T] {
        fn len(&self) -> usize { self.len() }
        fn is_empty(&self) -> bool { self.is_empty() }
    }
}
```

### 条件编译与泛型：
```aether
// 平台特定的泛型实现
#[cfg(target_os = "linux")]
impl<T> LinuxSpecific for T {
    fn linux_method(&self) { /* Linux特有实现 */ }
}

#[cfg(target_os = "windows")]
impl<T> WindowsSpecific for T {
    fn windows_method(&self) { /* Windows特有实现 */ }
}
```

## 泛型错误信息与调试

### 友好的编译错误：
```aether
// 当特质约束不满足时
fn process<T: Display>(value: T) {
    println!("{}", value);
}

struct SecretData { data: String }

process(SecretData { data: "secret".to_string() });  // 错误！

/*
错误：特质约束不满足
  --> src/main.aether:15:9
   |
15 | process(SecretData { data: "secret".to_string() });
   |         ^^^^^^^^^^ 类型`SecretData`未实现`Display`
   |
帮助：考虑为`SecretData`实现`Display`特质：
      impl Display for SecretData {
          fn fmt(&self, f: &mut Formatter) -> Result {
              write!(f, "SecretData({})", self.data)
          }
      }
      或者使用其他已实现`Display`的类型
*/
```

### 类型推导提示：
```aether
// 复杂的泛型推导
fn complex_generic<T, U, F>(a: T, b: U, f: F) -> U
where
    F: Fn(T) -> U,
{
    f(a)
}

val result = complex_generic(42, "hello", |x| x.to_string());
// 编译器提示：T推导为i32，U推导为String，F推导为闭包类型
```

## 实际业务中的泛型应用

### 数据访问层泛型：
```aether
// 泛型Repository模式
trait Repository<T, ID> {
    fn find_by_id(&self, id: ID) -> Option<T>;
    fn save(&mut self, entity: T) -> Result<(), DbError>;
    fn delete(&mut self, id: ID) -> Result<(), DbError>;
}

// 具体实现
struct UserRepository {
    connection: DbConnection,
}

impl Repository<User, UserId> for UserRepository {
    fn find_by_id(&self, id: UserId) -> Option<User> {
        // 具体数据库查询
        self.connection.query_user(id)
    }
    
    fn save(&mut self, user: User) -> Result<(), DbError> {
        self.connection.save_user(user)
    }
    
    fn delete(&mut self, id: UserId) -> Result<(), DbError> {
        self.connection.delete_user(id)
    }
}
```

### API响应泛型封装：
```aether
// 泛型API响应
struct ApiResponse<T> {
    success: bool,
    data: Option<T>,
    error: Option<ApiError>,
    pagination: Option<PaginationInfo>,
}

// 使用示例
fn get_users() -> ApiResponse<Vec<User>> {
    ApiResponse {
        success: true,
        data: Some(vec![User { /* ... */ }]),
        error: None,
        pagination: Some(PaginationInfo { page: 1, total: 100 }),
    }
}

fn get_user(id: UserId) -> ApiResponse<User> {
    // 单用户响应
}
```

### 中间件泛型链：
```aether
// 泛型中间件系统
trait Middleware<T> {
    fn process(&self, request: T) -> Result<T, MiddlewareError>;
}

// 组合多个中间件
fn chain_middleware<T>(
    request: T, 
    middlewares: &[Box<dyn Middleware<T>>]
) -> Result<T, MiddlewareError> {
    let mut current = request;
    for middleware in middlewares {
        current = middleware.process(current)?;
    }
    Ok(current)
}
```

## 泛型系统的限制与边界

### 特化限制：避免歧义
```aether
// 不允许歧义的特化
trait Processor<T> {
    fn process(&self, data: T);
}

// 通用实现
impl<T> Processor<T> for DefaultProcessor {
    fn process(&self, data: T) {
        // 默认处理
    }
}

// 特定类型特化 - 允许
impl Processor<String> for DefaultProcessor {
    fn process(&self, data: String) {
        // 字符串特殊处理
    }
}

// 歧义特化 - 编译错误！
// impl Processor<i32> for DefaultProcessor { ... }
// 如果存在另一个针对i32的特化，会产生歧义
```

### 孤儿规则：保持一致性
```aether
// 孤儿规则：不能为外部类型实现外部特质
// 以下代码会编译错误：

// 错误：为外部类型（String）实现外部特质（第三方库的Serializable）
// impl Serializable for String { ... }

// 解决方案：使用新类型包装
struct MyString(String);

impl Serializable for MyString {
    fn serialize(&self) -> String {
        self.0.clone()
    }
}
```

## 泛型最佳实践

### 1. 优先使用特质约束而非具体类型
```aether
// 好：使用特质约束
fn process<T: Display>(value: T) { ... }

// 不好：限制为具体类型
fn process_string(value: String) { ... }  // 只能处理String
```

### 2. 使用关联类型简化复杂签名
```aether
// 好：使用关联类型
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

// 不好：类型参数过多
trait BadIterator<T> {  // 每个方法都要带T
    fn next(&mut self) -> Option<T>;
}
```

### 3. 合理使用默认类型参数
```aether
// 为泛型参数提供默认值
struct Response<T = String, E = Error> {
    data: T,
    error: Option<E>,
}

// 使用默认值
val simple = Response { data: "ok", error: None };  // T=String, E=Error
val custom = Response<i32, DbError> { data: 42, error: None };
```

## 泛型系统总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 单态化 | 编译时生成特化代码 | 零运行时开销 |
| 特质约束 | 编译时验证类型能力 | 类型安全 |
| 关联类型 | 简化复杂特质签名 | 更好的API设计 |
| 生命周期 | 集成引用安全 | 内存安全 |
| 错误信息 | 友好的指导性错误 | 易于调试 |

**核心创新**：在保持强大表达力的同时，通过智能错误信息和性能优化，让泛型编程对普通开发者更加友好。

---

## 互动挑战：泛型设计练习

```aether
// 挑战1：设计一个泛型缓存系统
// 要求：支持任意类型，LRU淘汰策略，线程安全
// 你的设计：

// 挑战2：实现泛型事件总线
// 要求：类型安全的事件订阅/发布，支持异步处理
// 你的设计：

// 挑战3：优化以下泛型代码
fn poorly_designed<T, U, V>(a: T, b: U, c: V) -> Result<(T, U, V), ComplexError> 
where
    T: Clone + Display + Serialize + DeserializeOwned + PartialEq + PartialOrd + Hash,
    U: /* 类似复杂的约束 */,
    V: /* 更多约束 */
{
    // 实现...
}
```

**思考**：如何改进这些设计，使其更符合AetherLang的泛型最佳实践？

---

**下一节预告**：  
泛型系统设计完成后，我们将探索更高级的类型系统特性。在[3.3]中，我们将深入研究**特质系统**，包括特质对象、动态分发、特质继承等高级主题，让多态编程更加灵活和强大。

> "好的泛型设计应该像好的工具箱——每种工具都有明确的用途，但组合起来能解决无限的问题。"  
> —— AetherLang泛型设计哲学