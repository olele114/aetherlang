# 5.2 测试框架：确保代码质量与可靠性
**——从单元测试到基准测试的全方位测试支持**

> "测试是代码的信誉——没有测试的代码就像没有保险的汽车，开起来心里没底。"  
> —— 某位在深夜调试中领悟测试重要性的工程师

测试是软件开发中不可或缺的一部分。AetherLang的测试框架设计目标是：**全面、易用、高效**。我们提供从单元测试到性能基准测试的全套工具，让测试成为愉快的开发体验。

## 测试框架设计哲学

### 设计原则：
1. **零配置**：默认配置即可工作，无需复杂设置
2. **表达力强**：测试代码清晰易懂，接近自然语言
3. **并行安全**：测试可并行运行，互不干扰
4. **详细报告**：提供丰富的测试结果和诊断信息

## 单元测试

### 基础测试编写：
```aether
// 使用#[test]属性标记测试函数
#[test]
fn test_addition() {
    let result = add(2, 3);
    assert_eq!(result, 5);  // 断言相等
}

#[test]
fn test_division() {
    let result = divide(10, 2);
    assert_eq!(result, 5);
    
    // 测试异常情况
    assert_throws!(|| divide(10, 0), DivisionByZeroError);
}

// 测试函数可以返回Result
#[test]
fn test_with_result() -> Result<(), IoError> {
    let file = File::open("test.txt")?;
    // ... 测试逻辑
    Ok(())
}
```

### 测试组织：
```aether
// 测试模块
#[cfg(test)]  // 仅测试时编译
mod tests {
    use super::*;  // 导入父模块内容
    
    // 设置函数（每个测试前运行）
    fn setup() -> TestData {
        TestData::new()
    }
    
    // 清理函数（每个测试后运行）
    fn teardown(data: TestData) {
        data.cleanup();
    }
    
    #[test]
    fn test_one() {
        let data = setup();
        // 测试逻辑
        teardown(data);
    }
    
    // 使用夹具（fixture）重用设置
    #[fixture]
    fn database() -> DatabaseConnection {
        DatabaseConnection::new_test()
    }
    
    #[test]
    fn test_with_fixture(database: DatabaseConnection) {
        let user = database.get_user(1);
        assert!(user.is_some());
    }
}
```

## 集成测试

### 集成测试目录结构：
```
project/
├── src/
│   └── lib.aether
├── tests/               # 集成测试目录
│   ├── integration_test.aether
│   └── api_test.aether
└── aether.toml
```

### 集成测试示例：
```aether
// tests/integration_test.aether
use my_library::*;  // 导入被测试的库

#[test]
fn test_end_to_end() {
    let app = start_test_app();
    let client = TestClient::new(app);
    
    let response = client.get("/api/users");
    assert_eq!(response.status(), 200);
    assert!(response.json().is_array());
}

// 异步集成测试
#[async_test]
async test_async_integration() {
    let database = connect_to_test_db().await;
    let user = create_test_user(&database).await;
    
    assert_eq!(user.name, "Test User");
}
```

## 基准测试

### 性能基准测试：
```aether
// 基准测试函数
#[bench]
fn bench_fibonacci(b: &mut Benchmark) {
    b.iter(|| {
        fibonacci(30);  // 测量执行时间
    });
}

#[bench]
fn bench_sort_large_array(b: &mut Benchmark) {
    let data = generate_large_array();
    b.iter(|| {
        data.sort();  // 测量排序性能
    });
}

// 异步基准测试
#[async_bench]
async fn bench_async_operation(b: &mut AsyncBenchmark) {
    let client = HttpClient::new();
    b.iter(|| async {
        client.get("http://test.server/data").await;
    });
}
```

### 基准测试比较：
```aether
// 比较不同实现的性能
#[bench]
fn compare_implementations(b: &mut Benchmark) {
    let data = generate_test_data();
    
    b.group("serialization", |group| {
        group.bench("json", |b| {
            b.iter(|| data.to_json());
        });
        
        group.bench("message_pack", |b| {
            b.iter(|| data.to_msgpack());
        });
        
        group.bench("protobuf", |b| {
            b.iter(|| data.to_protobuf());
        });
    });
}
```

## 属性测试与模糊测试

### 属性测试（基于假设的测试）：
```aether
// 使用属性测试验证代码属性
#[proptest]
fn test_addition_properties(a: i32, b: i32) {
    // 交换律
    assert_eq!(add(a, b), add(b, a));
    
    // 结合律
    assert_eq!(add(add(a, b), c), add(a, add(b, c)));
    
    // 单位元
    assert_eq!(add(a, 0), a);
}

// 自定义生成器
#[proptest]
fn test_string_operations(s: String) {
    // 对于任意字符串，反转两次应得到原字符串
    let reversed = s.reverse().reverse();
    assert_eq!(s, reversed);
}
```

### 模糊测试（随机输入测试）：
```aether
// 模糊测试发现边界情况
#[fuzz_test]
fn test_parser_with_random_data(data: Vec<u8>) {
    // 对随机数据运行解析器，确保不崩溃
    let _ = Parser::parse(&data);  // 结果不重要，只要不panic
}

// 有针对性的模糊测试
#[fuzz_test]
fn test_specific_scenario(seed: u64) {
    let input = generate_complex_input(seed);
    let result = process_input(input);
    assert!(result.is_valid());
}
```

## 模拟与桩测试

### 模拟对象（Mocking）：
```aether
// 定义可模拟的特质
trait Database {
    fn get_user(&self, id: u64) -> Option<User>;
}

// 创建模拟对象
#[mock]  // 自动生成模拟实现
impl Database for MockDatabase {
    fn get_user(&self, id: u64) -> Option<User> {
        self.called("get_user").with(id).returning(|id| {
            if id == 1 {
                Some(User::new("Alice"))
            } else {
                None
            }
        })
    }
}

#[test]
fn test_with_mock() {
    let mock_db = MockDatabase::new();
    mock_db.expect_get_user(1).returns(Some(User::new("Alice")));
    
    let service = UserService::new(mock_db);
    let user = service.get_user(1);
    assert_eq!(user.name, "Alice");
    
    mock_db.verify();  // 验证所有预期调用都发生了
}
```

### 桩对象（Stubbing）：
```aether
// 创建桩对象简化测试
#[stub]
impl EmailService for StubEmailService {
    fn send_email(&self, to: &str, subject: &str) -> Result<(), EmailError> {
        // 桩实现，不实际发送邮件
        Ok(())
    }
}

#[test]
fn test_user_registration() {
    let email_stub = StubEmailService::new();
    let user_service = UserService::new(email_stub);
    
    let result = user_service.register("user@example.com");
    assert!(result.is_ok());
}
```

## 测试配置与环境

### 测试配置：
```aether
// 测试配置文件：test_config.aether
config! {
    test: {
        // 并行测试设置
        parallel: true,
        workers: 4,  // 并发测试线程数
        
        // 测试过滤
        filter: "test_*",  // 只运行匹配的测试
        skip: "slow_*",   // 跳过慢测试
        
        // 超时设置
        timeout: "30s",    // 单个测试超时时间
        
        // 覆盖率设置
        coverage: {
            enable: true,
            report: "html",  // 生成HTML报告
            threshold: 80    // 覆盖率阈值（百分比）
        }
    }
}
```

### 环境变量与测试：
```aether
// 使用环境变量控制测试行为
#[test]
fn test_external_service() {
    if env::var("TEST_EXTERNAL_SERVICES").is_ok() {
        // 只有设置了环境变量才运行外部服务测试
        test_real_service();
    } else {
        // 否则跳过或使用模拟
        test_with_mock();
    }
}

// 测试特定的环境设置
#[test]
#[env("DATABASE_URL", "postgres://test@localhost/test")]
fn test_with_database() {
    // 这个测试需要数据库连接
    let db = connect_to_db();
    // ... 测试逻辑
}
```

## 测试报告与输出

### 多样化报告格式：
```aether
// 运行测试并生成报告
aether test                      # 基本测试运行
aether test --format=pretty      # 彩色输出
aether test --format=json        # JSON格式（用于CI）
aether test --format=junit       # JUnit格式（Jenkins集成）
aether test --format=html        # HTML报告

// 带详细诊断信息
aether test --verbose            # 详细输出
aether test --show-output        # 显示测试输出（即使通过）
aether test --nocapture          # 不捕获输出（实时显示）
```

### 测试覆盖率报告：
```aether
// 生成覆盖率报告
aether test --coverage           # 运行测试并收集覆盖率
aether coverage report           # 生成覆盖率报告
aether coverage html             # 生成HTML覆盖率报告
aether coverage xml              # 生成XML报告（CI集成）

// 覆盖率阈值检查
aether coverage check --min 80   # 如果覆盖率低于80%则失败
```

## 高级测试模式

### 参数化测试：
```aether
// 同一测试多个输入
#[parameterized_test]
#[case(2, 3, 5)]
#[case(0, 0, 0)]
#[case(-1, 1, 0)]
fn test_addition_cases(a: i32, b: i32, expected: i32) {
    assert_eq!(add(a, b), expected);
}

// 从文件加载测试数据
#[parameterized_test]
#[file("test_data.csv")]
fn test_with_file_data(name: String, age: u32, expected: bool) {
    let user = User::new(name, age);
    assert_eq!(user.is_adult(), expected);
}
```

### 基于表的测试：
```aether
// 表格驱动测试
#[test]
fn test_arithmetic_operations() {
    let test_cases = table![
        // a, b, operation, expected
        (2, 3, "add", 5),
        (5, 2, "subtract", 3),
        (3, 4, "multiply", 12),
        (10, 2, "divide", 5),
    ];
    
    for (a, b, op, expected) in test_cases {
        let result = match op {
            "add" => add(a, b),
            "subtract" => subtract(a, b),
            "multiply" => multiply(a, b),
            "divide" => divide(a, b),
            _ => panic!("未知操作"),
        };
        assert_eq!(result, expected);
    }
}
```

## 测试工具与实用函数

### 测试辅助函数：
```aether
// 测试工具模块
mod test_utils {
    // 临时文件创建
    pub fn temp_file() -> TempFile {
        TempFile::new()
    }
    
    // 测试数据生成
    pub fn random_string(len: usize) -> String {
        // 生成随机字符串
    }
    
    // 异步测试辅助
    pub async fn with_timeout<F: Future>(future: F, timeout: Duration) -> F::Output {
        timeout(timeout, future).await.expect("测试超时")
    }
}

// 在测试中使用工具
#[test]
fn test_with_utils() {
    let file = test_utils::temp_file();
    write_test_data(&file);
    // 文件自动清理
}
```

### 自定义断言：
```aether
// 领域特定断言
fn assert_user_valid(user: &User) {
    assert!(!user.name.is_empty(), "用户名不能为空");
    assert!(user.age >= 0, "年龄不能为负");
    assert!(user.email.contains('@'), "邮箱格式无效");
}

#[test]
fn test_user_validation() {
    let user = User::new("Alice", 25);
    assert_user_valid(&user);
}

// 近似相等断言（用于浮点数）
fn assert_approx_eq(a: f64, b: f64, epsilon: f64) {
    assert!((a - b).abs() < epsilon, "{} 和 {} 相差超过 {}", a, b, epsilon);
}
```

## 持续集成集成

### CI配置文件示例：
```aether
// .aether-ci.aether 持续集成配置
pipeline! {
    name: "测试流水线",
    
    steps: [
        step!("安装依赖", || {
            aether install --locked
        }),
        
        step!("代码检查", || {
            aether check
            aether lint
            aether format --check
        }),
        
        step!("运行测试", || {
            aether test --coverage
            aether test --ignored  // 运行被忽略的测试
        }),
        
        step!("基准测试", || {
            aether bench --save-baseline main
        }),
        
        step!("生成文档", || {
            aether doc
        })
    ],
    
    // 质量门控
    quality_gates: [
        quality_gate!("测试通过率", || {
            test_pass_rate() > 95.0
        }),
        
        quality_gate!("覆盖率", || {
            coverage_rate() > 80.0
        }),
        
        quality_gate!("性能回归", || {
            !has_performance_regression()
        })
    ]
}
```

## 测试框架总结

| 特性 | AetherLang实现 | 优势 |
|------|----------------|------|
| 单元测试 | 简单属性标记 | 零配置，易于编写 |
| 集成测试 | 独立测试目录 | 清晰分离，端到端验证 |
| 基准测试 | 精确性能测量 | 性能回归检测 |
| 属性测试 | 自动生成测试数据 | 发现边界情况 |
| 模拟测试 | 自动模拟生成 | 隔离测试，快速执行 |

**核心创新**：在提供全面测试功能的同时，通过智能默认值和友好错误信息，让测试编写和维护变得简单愉快。

---

## 互动挑战：测试设计练习

```aether
// 挑战1：设计一个数据库事务测试框架
// 要求：支持事务回滚，测试数据隔离，并行测试安全
// 你的设计：

// 挑战2：实现一个HTTP API测试工具
// 要求：支持请求/响应模拟，状态验证，性能测试
// 你的设计：

// 挑战3：优化以下存在测试问题的代码
#[test]
fn problematic_test() {
    // 问题1：测试依赖外部服务
    let result = call_external_api();  // 不稳定
    
    // 问题2：测试不是幂等的
    create_user_in_database();  // 每次运行创建新用户
    
    // 问题3：断言信息不清晰
    assert!(complex_condition);  // 失败时不知道具体原因
}
```

**思考**：如何用AetherLang的测试框架改进这些测试？

---

**下一节预告**：  
测试框架设计完成后，我们将探索AetherLang的文档系统。在[5.3]中，我们将介绍如何生成美观的文档，并保持代码与文档的同步。

> "好的测试应该像好的侦探——不放过任何线索，验证所有假设，最终揭示真相。"  
> —— AetherLang测试框架设计哲学